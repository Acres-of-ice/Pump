// SPDX-FileCopyrightText: 2024 Cesanta Software Limited
// SPDX-License-Identifier: GPL-2.0-only or commercial
// Generated by Mongoose Wizard, https://mongoose.ws/wizard/

#include "mongoose_glue.h"
#include "esp_spiffs.h"
#include "driver/gpio.h"

#include "esp_ota_ops.h"
#include "esp_partition.h"

#include "esp_task_wdt.h"
#include "esp_log.h"

#include <inttypes.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>

#include "sim.h"

#include "esp_timer.h"
#include "esp_sntp.h"
#include <time.h>
#include <sys/time.h>

#include "camera_pin.h"
#include "esp_camera.h"


static bool s_ota_active = false;
// static esp_ota_handle_t s_ota_handle = 0;

// Determine pump type from Kconfig
#if defined(CONFIG_PUMP_BOREWELL)
    #define PUMP_TYPE "Borewell"
#elif defined(CONFIG_PUMP_1HP)
    #define PUMP_TYPE "1 HP"
#else
    #define PUMP_TYPE "Unknown"
#endif


extern char imsi_number[16];

#define LED_GPIO GPIO_NUM_8

#define PUMP_ON_GPIO  GPIO_NUM_39    
#define PUMP_OFF_GPIO GPIO_NUM_41   


static const char *TAG = "PUMP";
static const char *TAG_MQTT = "MG_MQTT";
static const char *TAG_SCHED = "MG_SCHED";
static const char *TAG_OTA = "MG_OTA";
static const char *TAG_RPC = "MG_RPC";
static const char *TAG_HB = "MG_HB";


extern void wifi_init(const char *ssid, const char *pass);

static esp_timer_handle_t s_heartbeat_timer = NULL;

#define TLS_CA ""


// #define PROJECT_VERSION 


static struct mg_rpc *s_rpc = NULL;
static uint8_t s_qos = 1;
static char s_device_id[40];

#define DEVICE_ID CONFIG_SITE_NAME
static const char *s_topic_prefix = "pump";

static esp_ota_handle_t s_ota_handle = 0;
static bool s_ota_in_progress = false;

static struct mg_connection *s_mqtt_conn = NULL;

static struct mg_connection *s_mqtt_connection = NULL;

// Add these after your existing global variables
static int64_t s_boot_time = 0;  // Boot timestamp in seconds
static char s_imsi[20] = "Unknown";  // IMSI number from SIM

struct device_state {
  bool pump_status;            // true = ON, false = OFF
  char firmware_version[20];
};
static struct device_state s_device_state = {false, PROJECT_VERSION};

// Scheduler structures
#define MAX_SCHEDULES 10





typedef struct {
  uint32_t id;           // Unique schedule ID
  int64_t start_time;    // Unix timestamp (seconds)
  uint32_t duration;     // Duration in seconds
  uint32_t interval;     // Repeat interval in seconds (0 = one-time)
  bool enabled;          // Is schedule active?
  int64_t last_run;      // Last execution time
} pump_schedule_t;

static pump_schedule_t s_schedules[MAX_SCHEDULES];
static int s_schedule_count = 0;
static esp_timer_handle_t s_scheduler_timer = NULL;

// Camera configuration
camera_config_t camera_config = {
    .pin_pwdn = CAM_PIN_PWDN,
    .pin_reset = CAM_PIN_RESET,
    .pin_xclk = CAM_PIN_XCLK,
    .pin_sscb_sda = CAM_PIN_SIOD,
    .pin_sscb_scl = CAM_PIN_SIOC,

    .pin_d7 = CAM_PIN_D7,
    .pin_d6 = CAM_PIN_D6,
    .pin_d5 = CAM_PIN_D5,
    .pin_d4 = CAM_PIN_D4,
    .pin_d3 = CAM_PIN_D3,
    .pin_d2 = CAM_PIN_D2,
    .pin_d1 = CAM_PIN_D1,
    .pin_d0 = CAM_PIN_D0,
    .pin_vsync = CAM_PIN_VSYNC,
    .pin_href = CAM_PIN_HREF,
    .pin_pclk = CAM_PIN_PCLK,

    // XCLK at 16MHz for DMA stability (prevents EOF overflow)
    .xclk_freq_hz = 16000000,
    .ledc_timer = LEDC_TIMER_0,
    .ledc_channel = LEDC_CHANNEL_0,

    .pixel_format = PIXFORMAT_JPEG, // YUV422,GRAYSCALE,RGB565,JPEG
    .frame_size =
        FRAMESIZE_VGA, // QQVGA-UXGA Do not use sizes above QVGA when not JPEG

    .jpeg_quality =
        8,         // 0-63 lower=highest quality (8 = excellent quality, stable)
    .fb_count = 2, // 2 frame buffers for stability
    // .fb_location = CAMERA_FB_IN_DRAM,    // Frame buffers in PSRAM
    .grab_mode = CAMERA_GRAB_WHEN_EMPTY, // Wait for buffer to be available
    .sccb_i2c_port = 0                   // Use I2C port 0
};


static bool camera_initialized = false;


static void scheduler_check_callback(void *arg);
static void pump_turn_on(uint32_t duration_seconds);
static void pump_turn_off_callback(void *arg);
static void capture_and_send_photo(struct mg_connection *c);





static char *make_topic_name(char *buf, size_t len, const char *suffix) {
  mg_snprintf(buf, len, "%s/%s/%s", s_topic_prefix, CONFIG_DEVICE_ID, suffix);
  return buf;
}


static void publish_status(struct mg_connection *c) {
  char topic[100];
  char json[256];
  struct mg_mqtt_opts pub_opts;
  
  snprintf(json, sizeof(json),
    "{\"method\":\"status.notify\",\"params\":{\"status\":\"online\","
    "\"pump_status\":%s,\"firmware_version\":\"%s\"}}",
    s_device_state.pump_status ? "true" : "false", 
    s_device_state.firmware_version);

  memset(&pub_opts, 0, sizeof(pub_opts));
  pub_opts.topic = mg_str(make_topic_name(topic, sizeof(topic), "status"));
  pub_opts.message = mg_str(json);
  pub_opts.qos = s_qos;
  pub_opts.retain = false;  // âœ… CHANGE: Don't retain heartbeats
  mg_mqtt_pub(c, &pub_opts);
}


// Get current Unix timestamp
static int64_t get_current_timestamp(void) {
  struct timeval tv;
  gettimeofday(&tv, NULL);
  return (int64_t)tv.tv_sec;
}

// Turn pump ON for a specific duration
static void pump_turn_on(uint32_t duration_seconds) {
  ESP_LOGD(TAG_SCHED, "Turning pump ON for %lu seconds", duration_seconds);
  
  s_device_state.pump_status = true;

  #ifdef CONFIG_PUMP_BOREWELL
    gpio_set_level(PUMP_ON_GPIO, 1);
    gpio_set_level(PUMP_OFF_GPIO, 0);

    vTaskDelay(pdMS_TO_TICKS(3000));

    gpio_set_level(PUMP_ON_GPIO, 0);
    gpio_set_level(PUMP_OFF_GPIO, 0);
  #endif

  #ifdef CONFIG_PUMP_1HP
    gpio_set_level(PUMP_ON_GPIO, 1);
  #endif

  
  // Publish status update
  if (s_mqtt_connection) {
    publish_status(s_mqtt_connection);
  }
  
  // Create one-shot timer to turn OFF after duration
  esp_timer_handle_t off_timer;
  esp_timer_create_args_t off_timer_args = {
    .callback = &pump_turn_off_callback,
    .arg = NULL,
    .name = "pump_off"
  };
  
  esp_timer_create(&off_timer_args, &off_timer);
  esp_timer_start_once(off_timer, duration_seconds * 1000000ULL);
}

// Timer callback to turn pump OFF
static void pump_turn_off_callback(void *arg) {
  ESP_LOGD(TAG_SCHED, "Turning pump OFF (duration expired)");
  
  s_device_state.pump_status = false;
  #ifdef CONFIG_PUMP_BOREWELL
    gpio_set_level(PUMP_ON_GPIO, 0);
    gpio_set_level(PUMP_OFF_GPIO, 1);

    vTaskDelay(pdMS_TO_TICKS(3000));

    gpio_set_level(PUMP_ON_GPIO, 0);
    gpio_set_level(PUMP_OFF_GPIO, 0);
  #endif

  #ifdef CONFIG_PUMP_1HP
    gpio_set_level(PUMP_ON_GPIO, 0);
  #endif
  // Publish status update
  if (s_mqtt_connection) {
    publish_status(s_mqtt_connection);
  }
}

// Check all schedules and execute if needed
static void scheduler_check_callback(void *arg) {
  int64_t now = get_current_timestamp();
  
  for (int i = 0; i < s_schedule_count; i++) {
    pump_schedule_t *sched = &s_schedules[i];
    
    if (!sched->enabled) continue;
    
    // Check if it's time to run this schedule
    bool should_run = false;
    
    if (sched->interval == 0) {
      // One-time schedule
      if (now >= sched->start_time && sched->last_run == 0) {
        should_run = true;
      }
    } else {
      // Recurring schedule
      if (now >= sched->start_time) {
        int64_t time_since_last = now - sched->last_run;
        
        if (sched->last_run == 0 || time_since_last >= sched->interval) {
          should_run = true;
        }
      }
    }
    
    if (should_run) {
      ESP_LOGD(TAG_SCHED, "Executing schedule ID %lu", sched->id);
      sched->last_run = now;
      pump_turn_on(sched->duration);
      
      // Disable one-time schedules after execution
      if (sched->interval == 0) {
        sched->enabled = false;
      }
    }
  }
}

// Initialize scheduler
static void scheduler_init(void) {
  // Create periodic timer that checks every 10 seconds
  esp_timer_create_args_t timer_args = {
    .callback = &scheduler_check_callback,
    .arg = NULL,
    .name = "scheduler"
  };
  
  esp_timer_create(&timer_args, &s_scheduler_timer);
  esp_timer_start_periodic(s_scheduler_timer, 10 * 1000000); // 10 seconds

  ESP_LOGD(TAG_SCHED, "Scheduler initialized (10s check interval)");
}

// Add a new schedule
static void rpc_schedule_add(struct mg_rpc_req *r) {
  if (s_schedule_count >= MAX_SCHEDULES) {
    char response[128];
    snprintf(response, sizeof(response), "{\"id\":null,\"error\":\"Maximum schedules reached\"}");

    if (s_mqtt_connection) {
      char topic[100];
      struct mg_mqtt_opts pub_opts;
      memset(&pub_opts, 0, sizeof(pub_opts));
      pub_opts.topic = mg_str(make_topic_name(topic, sizeof(topic), "tx"));
      pub_opts.message = mg_str(response);
      pub_opts.qos = 1;
      mg_mqtt_pub(s_mqtt_connection, &pub_opts);
    }
    return;
  }

  // Parse and validate inputs
  int64_t start_time = mg_json_get_long(r->frame, "$.params.start", 0);
  int64_t duration = mg_json_get_long(r->frame, "$.params.duration", 0);
  int64_t interval = mg_json_get_long(r->frame, "$.params.interval", 0);

  // Validation: start_time must be positive (valid Unix timestamp)
  if (start_time <= 0) {
    char response[128];
    snprintf(response, sizeof(response), "{\"id\":null,\"error\":\"Invalid start_time: must be positive\"}");
    if (s_mqtt_connection) {
      char topic[100];
      struct mg_mqtt_opts pub_opts;
      memset(&pub_opts, 0, sizeof(pub_opts));
      pub_opts.topic = mg_str(make_topic_name(topic, sizeof(topic), "tx"));
      pub_opts.message = mg_str(response);
      pub_opts.qos = 1;
      mg_mqtt_pub(s_mqtt_connection, &pub_opts);
    }
    return;
  }

  // Validation: duration must be between 1 second and 24 hours (86400 seconds)
  if (duration <= 0 || duration > 86400) {
    char response[128];
    snprintf(response, sizeof(response), "{\"id\":null,\"error\":\"Invalid duration: must be 1-86400 seconds\"}");
    if (s_mqtt_connection) {
      char topic[100];
      struct mg_mqtt_opts pub_opts;
      memset(&pub_opts, 0, sizeof(pub_opts));
      pub_opts.topic = mg_str(make_topic_name(topic, sizeof(topic), "tx"));
      pub_opts.message = mg_str(response);
      pub_opts.qos = 1;
      mg_mqtt_pub(s_mqtt_connection, &pub_opts);
    }
    return;
  }

  // Validation: interval must be 0 (one-time) or at least equal to duration
  if (interval < 0 || (interval > 0 && interval < duration)) {
    char response[128];
    snprintf(response, sizeof(response), "{\"id\":null,\"error\":\"Invalid interval: must be 0 or >= duration\"}");
    if (s_mqtt_connection) {
      char topic[100];
      struct mg_mqtt_opts pub_opts;
      memset(&pub_opts, 0, sizeof(pub_opts));
      pub_opts.topic = mg_str(make_topic_name(topic, sizeof(topic), "tx"));
      pub_opts.message = mg_str(response);
      pub_opts.qos = 1;
      mg_mqtt_pub(s_mqtt_connection, &pub_opts);
    }
    return;
  }

  pump_schedule_t *sched = &s_schedules[s_schedule_count];

  sched->id = mg_json_get_long(r->frame, "$.params.id", 0);
  sched->start_time = start_time;
  sched->duration = (uint32_t)duration;
  sched->interval = (uint32_t)interval;
  mg_json_get_bool(r->frame, "$.params.enabled", &sched->enabled);
  sched->last_run = 0;

  s_schedule_count++;

  ESP_LOGD(TAG_SCHED, "Added schedule: ID=%lu, Start=%lld, Duration=%lu, Interval=%lu",
           sched->id, sched->start_time, sched->duration, sched->interval);
  
  // Send success response
  char response[128];
  snprintf(response, sizeof(response), "{\"id\":null,\"result\":\"ok\"}");
  
  if (s_mqtt_connection) {
    char topic[100];
    struct mg_mqtt_opts pub_opts;
    memset(&pub_opts, 0, sizeof(pub_opts));
    pub_opts.topic = mg_str(make_topic_name(topic, sizeof(topic), "tx"));
    pub_opts.message = mg_str(response);
    pub_opts.qos = 1;
    mg_mqtt_pub(s_mqtt_connection, &pub_opts);
  }
}

// Delete a schedule
static void rpc_schedule_delete(struct mg_rpc_req *r) {
  uint32_t id = mg_json_get_long(r->frame, "$.params.id", 0);
  
  for (int i = 0; i < s_schedule_count; i++) {
    if (s_schedules[i].id == id) {
      // Shift remaining schedules
      for (int j = i; j < s_schedule_count - 1; j++) {
        s_schedules[j] = s_schedules[j + 1];
      }
      s_schedule_count--;

      ESP_LOGD(TAG_SCHED, "Deleted schedule ID %lu", id);
      
      // Send response
      char response[128];
      snprintf(response, sizeof(response), "{\"id\":null,\"result\":\"ok\"}");
      
      if (s_mqtt_connection) {
        char topic[100];
        struct mg_mqtt_opts pub_opts;
        memset(&pub_opts, 0, sizeof(pub_opts));
        pub_opts.topic = mg_str(make_topic_name(topic, sizeof(topic), "tx"));
        pub_opts.message = mg_str(response);
        pub_opts.qos = 1;
        mg_mqtt_pub(s_mqtt_connection, &pub_opts);
      }
      return;
    }
  }
  
  // Not found
  char response[128];
  snprintf(response, sizeof(response), "{\"id\":null,\"error\":\"Schedule not found\"}");
  
  if (s_mqtt_connection) {
    char topic[100];
    struct mg_mqtt_opts pub_opts;
    memset(&pub_opts, 0, sizeof(pub_opts));
    pub_opts.topic = mg_str(make_topic_name(topic, sizeof(topic), "tx"));
    pub_opts.message = mg_str(response);
    pub_opts.qos = 1;
    mg_mqtt_pub(s_mqtt_connection, &pub_opts);
  }
}

// Toggle schedule enabled/disabled
static void rpc_schedule_toggle(struct mg_rpc_req *r) {
  uint32_t id = mg_json_get_long(r->frame, "$.params.id", 0);
  bool enabled = false;
  mg_json_get_bool(r->frame, "$.params.enabled", &enabled);
  
  for (int i = 0; i < s_schedule_count; i++) {
    if (s_schedules[i].id == id) {
      s_schedules[i].enabled = enabled;
      ESP_LOGD(TAG_SCHED, "Schedule ID %lu %s", id, enabled ? "enabled" : "disabled");
      
      // Send response
      char response[128];
      snprintf(response, sizeof(response), "{\"id\":null,\"result\":\"ok\"}");
      
      if (s_mqtt_connection) {
        char topic[100];
        struct mg_mqtt_opts pub_opts;
        memset(&pub_opts, 0, sizeof(pub_opts));
        pub_opts.topic = mg_str(make_topic_name(topic, sizeof(topic), "tx"));
        pub_opts.message = mg_str(response);
        pub_opts.qos = 1;
        mg_mqtt_pub(s_mqtt_connection, &pub_opts);
      }
      return;
    }
  }
  
  // Not found
  char response[128];
  snprintf(response, sizeof(response), "{\"id\":null,\"error\":\"Schedule not found\"}");
  
  if (s_mqtt_connection) {
    char topic[100];
    struct mg_mqtt_opts pub_opts;
    memset(&pub_opts, 0, sizeof(pub_opts));
    pub_opts.topic = mg_str(make_topic_name(topic, sizeof(topic), "tx"));
    pub_opts.message = mg_str(response);
    pub_opts.qos = 1;
    mg_mqtt_pub(s_mqtt_connection, &pub_opts);
  }
}

// List all schedules
static void rpc_schedule_list(struct mg_rpc_req *r) {
  char json[1024];
  int offset = 0;
  
  offset += snprintf(json + offset, sizeof(json) - offset,
                     "{\"id\":null,\"result\":{\"schedules\":[");
  
  for (int i = 0; i < s_schedule_count; i++) {
    pump_schedule_t *s = &s_schedules[i];
    offset += snprintf(json + offset, sizeof(json) - offset,
                       "%s{\"id\":%lu,\"start\":%lld,\"duration\":%lu,"
                       "\"interval\":%lu,\"enabled\":%s,\"last_run\":%lld}",
                       i > 0 ? "," : "",
                       s->id, s->start_time, s->duration,
                       s->interval, s->enabled ? "true" : "false",
                       s->last_run);
  }
  
  offset += snprintf(json + offset, sizeof(json) - offset, "]}}");

  ESP_LOGD(TAG_SCHED, "Listing %d schedules", s_schedule_count);
  
  if (s_mqtt_connection) {
    char topic[100];
    struct mg_mqtt_opts pub_opts;
    memset(&pub_opts, 0, sizeof(pub_opts));
    pub_opts.topic = mg_str(make_topic_name(topic, sizeof(topic), "tx"));
    pub_opts.message = mg_str_n(json, offset);
    pub_opts.qos = 1;
    mg_mqtt_pub(s_mqtt_connection, &pub_opts);
  }
}


static void publish_response(struct mg_connection *c, char *buf, size_t len) {
  struct mg_mqtt_opts pub_opts;
  char topic[100];
  memset(&pub_opts, 0, sizeof(pub_opts));
  pub_opts.topic = mg_str(make_topic_name(topic, sizeof(topic), "tx"));
  pub_opts.message = mg_str_n(buf, len);
  pub_opts.qos = s_qos;
  mg_mqtt_pub(c, &pub_opts);
}


static void rpc_ota_upload(struct mg_rpc_req *r) {
  long ofs = mg_json_get_long(r->frame, "$.params.offset", -1);
  long tot = mg_json_get_long(r->frame, "$.params.total", -1);
  int len = 0;
  char *buf = mg_json_get_b64(r->frame, "$.params.chunk", &len);

  ESP_LOGD(TAG_OTA, "OTA chunk: offset=%ld total=%ld len=%d", ofs, tot, len);

  if (buf == NULL) {
    ESP_LOGE(TAG_OTA, "Buffer is NULL");
    
    char response[128];
    snprintf(response, sizeof(response), 
      "{\"method\":\"ota.ack\",\"params\":{\"offset\":%ld,\"status\":\"error\"}}",
      ofs);
    
    if (s_mqtt_connection) {
      char topic[100];
      struct mg_mqtt_opts pub_opts;
      memset(&pub_opts, 0, sizeof(pub_opts));
      pub_opts.topic = mg_str(make_topic_name(topic, sizeof(topic), "tx"));
      pub_opts.message = mg_str(response);
      pub_opts.qos = 1;
      mg_mqtt_pub(s_mqtt_connection, &pub_opts);
    }
  } else {
    bool success = true;

    if (ofs < 0 || tot < 0) {
      ESP_LOGE(TAG_OTA, "Invalid params");
      success = false;
    } else if (ofs == 0 && mg_ota_begin((size_t) tot) == false) {
      ESP_LOGE(TAG_OTA, "mg_ota_begin failed");
      mg_ota_end();
      success = false;
    } else if (len > 0 && mg_ota_write(buf, len) == false) {
      ESP_LOGE(TAG_OTA, "mg_ota_write failed");
      mg_ota_end();
      success = false;
    } else if (ofs + len >= tot && mg_ota_end() == false) {
      ESP_LOGE(TAG_OTA, "mg_ota_end failed");
      success = false;
    }

    // âœ… IMPROVED: Better handling of last chunk
    bool isLastChunk = (ofs + len >= tot);
    
    if (success) {
      ESP_LOGD(TAG_OTA, "Progress: %.1f%% (%ld/%ld)", (ofs + len) * 100.0 / tot, ofs + len, tot);
      
      if (isLastChunk) {
        // âœ… Last chunk - send completion message
        ESP_LOGI(TAG_OTA, "OTA COMPLETE! Sending completion message...");
        
        char complete_msg[128];
        snprintf(complete_msg, sizeof(complete_msg), 
          "{\"method\":\"ota.complete\",\"params\":{\"status\":\"success\"}}");
        
        if (s_mqtt_connection) {
          char topic[100];
          struct mg_mqtt_opts pub_opts;
          memset(&pub_opts, 0, sizeof(pub_opts));
          pub_opts.topic = mg_str(make_topic_name(topic, sizeof(topic), "tx"));
          pub_opts.message = mg_str(complete_msg);
          pub_opts.qos = 1;
          pub_opts.retain = false;
          mg_mqtt_pub(s_mqtt_connection, &pub_opts);
          
          // âœ… CRITICAL: Give MQTT time to actually send the message
          ESP_LOGD(TAG_OTA, "Waiting for message to be sent...");
          
          // Process any pending MQTT messages
          for (int i = 0; i < 20; i++) {
            mg_mgr_poll(&g_mgr, 100);  // Poll for 100ms each iteration
            vTaskDelay(pdMS_TO_TICKS(100));
          }
          
          ESP_LOGI(TAG_OTA, "Rebooting now...");
        }
        
        vTaskDelay(pdMS_TO_TICKS(500)); // Final safety delay
        esp_restart();
      } else {
        // âœ… Regular chunk - send ACK
        char response[128];
        snprintf(response, sizeof(response), 
          "{\"method\":\"ota.ack\",\"params\":{\"offset\":%ld,\"status\":\"ok\"}}",
          ofs);
        
        if (s_mqtt_connection) {
          char topic[100];
          struct mg_mqtt_opts pub_opts;
          memset(&pub_opts, 0, sizeof(pub_opts));
          pub_opts.topic = mg_str(make_topic_name(topic, sizeof(topic), "tx"));
          pub_opts.message = mg_str(response);
          pub_opts.qos = 1;
          mg_mqtt_pub(s_mqtt_connection, &pub_opts);
          ESP_LOGD(TAG_OTA, "ACK sent for offset %ld", ofs);
        }
      }
    } else {
      // Send error response
      char response[128];
      snprintf(response, sizeof(response), 
        "{\"method\":\"ota.ack\",\"params\":{\"offset\":%ld,\"status\":\"error\"}}",
        ofs);
      
      if (s_mqtt_connection) {
        char topic[100];
        struct mg_mqtt_opts pub_opts;
        memset(&pub_opts, 0, sizeof(pub_opts));
        pub_opts.topic = mg_str(make_topic_name(topic, sizeof(topic), "tx"));
        pub_opts.message = mg_str(response);
        pub_opts.qos = 1;
        mg_mqtt_pub(s_mqtt_connection, &pub_opts);
      }
    }

    mg_free(buf);
  }
}

void my_mqtt_tls_init(struct mg_connection *c) {
  bool is_tls = mg_url_is_ssl(WIZARD_MQTT_URL);
  ESP_LOGD(TAG_MQTT, "Connection %lu TLS enabled: %s", c->id, is_tls ? "yes" : "no");
  if (is_tls) {
    struct mg_tls_opts opts = {0};
    opts.ca = mg_str(TLS_CA);
    opts.name = mg_url_host(WIZARD_MQTT_URL);
    mg_tls_init(c, &opts);
  }
}

void my_mqtt_on_connect(struct mg_connection *c, int code) {
  char topic[100];
  struct mg_mqtt_opts opts = {0};
  
  // âœ… CRITICAL FIX: Store the connection globally so rpc_ota_upload can use it
  s_mqtt_connection = c;
  ESP_LOGD(TAG_MQTT, "MQTT connection stored: %p", c);
  
  opts.qos = 1;
  opts.topic = mg_str(make_topic_name(topic, sizeof(topic), "rx"));
  mg_mqtt_sub(c, &opts);

#if CONFIG_ENABLE_CAMERA
  // âœ… Subscribe to simcam do topic (only if camera enabled)
  mg_snprintf(topic, sizeof(topic), "simcam/%s/do", CONFIG_DEVICE_ID);
  opts.topic = mg_str(topic);
  mg_mqtt_sub(c, &opts);
  ESP_LOGI(TAG_MQTT, "Subscribed to simcam do topic");
#endif 
  publish_status(c);
  ESP_LOGI(TAG_MQTT, "Connected (code %d), subscribed to rx topic", code);
}


void my_mqtt_on_message(struct mg_connection *c, struct mg_str topic, struct mg_str data) {
  // âœ… FIX: Check message type WITHOUT copying entire buffer
  bool is_json = (data.len > 0 && data.buf[0] == '{');
  bool is_rpc_method = false;
  
  if (is_json && data.len > 10) {
    // Check if it contains "method" field
    is_rpc_method = (mg_json_get(data, "$.method", NULL) > 0);
  }

  // âœ… For logging, only copy first 200 chars
  char preview[256];
  int preview_len = (data.len < 200) ? data.len : 200;
  memcpy(preview, data.buf, preview_len);
  preview[preview_len] = '\0';
  ESP_LOGD(TAG_MQTT, "RX (%d bytes): %s%s", (int)data.len, preview, data.len > 200 ? "..." : "");

#if CONFIG_ENABLE_CAMERA
  // âœ… Check if this is simcam/do topic (camera commands)
  char simcam_topic[100];
  mg_snprintf(simcam_topic, sizeof(simcam_topic), "simcam/%s/do", CONFIG_DEVICE_ID);
  
  if (topic.len == strlen(simcam_topic) && 
      strncmp(topic.buf, simcam_topic, topic.len) == 0) {
    
    // Handle camera commands on simcam topic
    if (!is_rpc_method && data.len < 100) {
      char small_buf[128];
      int copy_len = (data.len < 100) ? data.len : 100;
      memcpy(small_buf, data.buf, copy_len);
      small_buf[copy_len] = '\0';
      
      for (int i = 0; i < copy_len; i++) {
        small_buf[i] = tolower((unsigned char)small_buf[i]);
      }
      
      if (strstr(small_buf, "pic") != NULL) {
        ESP_LOGI(TAG_MQTT, "ðŸ“¸ Camera request received on simcam/do");
        capture_and_send_photo(c);
        return;
      }
    }
    
    ESP_LOGW(TAG_MQTT, "Unhandled simcam command");
    return;
  }
#endif

  // âœ… Handle STATUS REQUEST
  if (!is_rpc_method && data.len < 100) {
    // For short messages, check if it's a status request
    char small_buf[128];
    int copy_len = (data.len < 100) ? data.len : 100;
    memcpy(small_buf, data.buf, copy_len);
    small_buf[copy_len] = '\0';
    
    // Convert to lowercase for case-insensitive comparison
    for (int i = 0; i < copy_len; i++) {
      small_buf[i] = tolower((unsigned char)small_buf[i]);
    }
    
    if (strstr(small_buf, "status") != NULL) {
      ESP_LOGD(TAG_MQTT, "Status request received");
      
      // Calculate uptime
      int64_t current_time = get_current_timestamp();
      int64_t uptime_seconds = current_time - s_boot_time;
      int uptime_days = uptime_seconds / 86400;
      int uptime_hours = (uptime_seconds % 86400) / 3600;
      int uptime_minutes = (uptime_seconds % 3600) / 60;
      
      char uptime_str[64];
      if (uptime_days > 0) {
        snprintf(uptime_str, sizeof(uptime_str), "%d days, %d hours", uptime_days, uptime_hours);
      } else if (uptime_hours > 0) {
        snprintf(uptime_str, sizeof(uptime_str), "%d hours, %d minutes", uptime_hours, uptime_minutes);
      } else {
        snprintf(uptime_str, sizeof(uptime_str), "%d minutes", uptime_minutes);
      }
      
      char response[512];
      snprintf(response, sizeof(response),
        "{\"method\":\"status.response\",\"params\":{"
        "\"site_name\":\"%s\","
        "\"firmware_version\":\"%s\","
        "\"pump_type\":\"%s\"," 
        "\"pump_status\":\"%s\","
        "\"imsi\":\"%s\","
        "\"uptime\":\"%s\"}}",
        CONFIG_DEVICE_ID,
        s_device_state.firmware_version,
        PUMP_TYPE,
        s_device_state.pump_status ? "ON" : "OFF",
        imsi_number,
        uptime_str);
      
      char topic_tx[100];
      struct mg_mqtt_opts pub_opts;
      memset(&pub_opts, 0, sizeof(pub_opts));
      pub_opts.topic = mg_str(make_topic_name(topic_tx, sizeof(topic_tx), "tx"));
      pub_opts.message = mg_str(response);
      pub_opts.qos = 1;
      mg_mqtt_pub(c, &pub_opts);

      ESP_LOGD(TAG_MQTT, "Status response sent");
      return;
    }
  }

    if (!is_rpc_method && data.len < 100) {
    char small_buf[128];
    int copy_len = (data.len < 100) ? data.len : 100;
    memcpy(small_buf, data.buf, copy_len);
    small_buf[copy_len] = '\0';
    
    // Convert to lowercase
    for (int i = 0; i < copy_len; i++) {
      small_buf[i] = tolower((unsigned char)small_buf[i]);
    }
    
    if (strstr(small_buf, "pic") != NULL) {
      ESP_LOGI(TAG_MQTT, "ðŸ“¸ Camera request received");
      capture_and_send_photo(c);
      return;
    }
  }

  // âœ… Handle JSON-RPC messages (OTA, Scheduler, etc.)
  if (is_rpc_method) {
    ESP_LOGD(TAG_RPC, "Processing RPC command...");
    struct mg_iobuf io = {0, 0, 0, 512};

    struct mg_rpc_req rpc_req = {&s_rpc, NULL, mg_pfn_iobuf, &io, NULL, data};

    mg_rpc_process(&rpc_req);

    if (io.buf && io.len > 0) {
      ESP_LOGD(TAG_RPC, "Response: %.*s", (int)io.len, (char*)io.buf);
      publish_response(c, (char *) io.buf, io.len);
      ESP_LOGD(TAG_RPC, "RPC response published");
      publish_status(c);
    } else {
      ESP_LOGD(TAG_RPC, "No response in buffer (manual publish was used)");
    }

    mg_iobuf_free(&io);
    return;
  }

  // âœ… Handle DIRECT PUMP CONTROL (only for simple text commands)
  if (!is_json && data.len < 100) {
    // Only copy small messages for pump control
    char cmd[128];
    int cmd_len = (data.len < 100) ? data.len : 100;
    memcpy(cmd, data.buf, cmd_len);
    cmd[cmd_len] = '\0';
    
    // Convert to uppercase for comparison
    for (int i = 0; i < cmd_len; i++) {
      cmd[i] = toupper((unsigned char)cmd[i]);
    }
    
    if (strstr(cmd, "ON") != NULL && strstr(cmd, "PUMP") != NULL) {
      ESP_LOGD(TAG, "PUMP ON triggered (direct command)");
      s_device_state.pump_status = true;
      
#ifdef CONFIG_PUMP_BOREWELL
      gpio_set_level(PUMP_ON_GPIO, 1);
      gpio_set_level(PUMP_OFF_GPIO, 0);
      vTaskDelay(pdMS_TO_TICKS(3000));
      gpio_set_level(PUMP_ON_GPIO, 0);
      gpio_set_level(PUMP_OFF_GPIO, 0);
#endif

#ifdef CONFIG_PUMP_1HP
      gpio_set_level(PUMP_ON_GPIO, 1);
#endif
      
      publish_status(c);
      return;
    }
    else if (strstr(cmd, "OFF") != NULL && strstr(cmd, "PUMP") != NULL) {
      ESP_LOGD(TAG, "PUMP OFF triggered (direct command)");
      s_device_state.pump_status = false;
      
#ifdef CONFIG_PUMP_BOREWELL
      gpio_set_level(PUMP_ON_GPIO, 0);
      gpio_set_level(PUMP_OFF_GPIO, 1);
      vTaskDelay(pdMS_TO_TICKS(3000));
      gpio_set_level(PUMP_ON_GPIO, 0);
      gpio_set_level(PUMP_OFF_GPIO, 0);
#endif

#ifdef CONFIG_PUMP_1HP
      gpio_set_level(PUMP_ON_GPIO, 0);
#endif
      
      publish_status(c);
      return;
    }
  }

  ESP_LOGW(TAG_MQTT, "Unhandled message (%d bytes)", (int)data.len);
}

void my_mqtt_set_connection(struct mg_connection *c) {
  s_mqtt_connection = c;
  ESP_LOGD(TAG_MQTT, "MQTT connection stored: %p", c);
}
struct mg_connection *my_mqtt_connect(mg_event_handler_t fn) {
  const char *url = WIZARD_MQTT_URL;
  char topic[100], message[200];
  struct mg_mqtt_opts opts;
  struct mg_connection *c;

  // Initialize opts to zero
  memset(&opts, 0, sizeof(opts));

  // âœ… ONLINE MESSAGE - Sent when device connects
  snprintf(message, sizeof(message),
    "{\"method\":\"status.notify\",\"params\":{\"status\":\"online\",\"pump_status\":%s,\"firmware_version\":\"%s\"}}",
    s_device_state.pump_status ? "true" : "false",
    s_device_state.firmware_version);

  // Basic MQTT options
  opts.clean = true;
  opts.qos = s_qos;
  opts.topic = mg_str(make_topic_name(topic, sizeof(topic), "status"));
  opts.version = 4;  // MQTT 3.1.1
  opts.retain = true;
  opts.message = mg_str(message);

  // âœ… MQTT Authentication - extract user/pass from URL
  opts.user = mg_url_user(url);
  opts.pass = mg_url_pass(url);

  // âœ… KEEP ALIVE - Critical for timeout detection!
  // Sends ping every 60 seconds, dashboard will detect offline if no ping received
  opts.keepalive = 20;
  
  // No LWT support in this Mongoose version
  // Dashboard will detect offline via timeout (90 seconds without heartbeat)

  // Register RPC handlers (only once)
  if (s_rpc == NULL) {
    mg_rpc_add(&s_rpc, mg_str("ota.upload"), rpc_ota_upload, NULL);
    mg_rpc_add(&s_rpc, mg_str("schedule.add"), rpc_schedule_add, NULL);
    mg_rpc_add(&s_rpc, mg_str("schedule.delete"), rpc_schedule_delete, NULL);
    mg_rpc_add(&s_rpc, mg_str("schedule.toggle"), rpc_schedule_toggle, NULL);
    mg_rpc_add(&s_rpc, mg_str("schedule.list"), rpc_schedule_list, NULL);
  }

  if ((c = mg_mqtt_connect(&g_mgr, url, &opts, fn, NULL)) != NULL) {
    ESP_LOGI(TAG_MQTT, "Connection %lu initiated with keepalive=%d", c->id, opts.keepalive);
  }
  return c;
}

// âœ… IMPORTANT: Add this function to handle graceful shutdown (optional)
// Call this if you want to send offline status before restart
void mqtt_send_offline_status(void) {
  if (s_mqtt_connection != NULL) {
    char topic[100];
    char json[256];
    struct mg_mqtt_opts pub_opts;
    
    snprintf(json, sizeof(json),
      "{\"method\":\"status.notify\",\"params\":{\"status\":\"offline\"}}");

    memset(&pub_opts, 0, sizeof(pub_opts));
    pub_opts.topic = mg_str(make_topic_name(topic, sizeof(topic), "status"));
    pub_opts.message = mg_str(json);
    pub_opts.qos = s_qos;
    pub_opts.retain = true;
    mg_mqtt_pub(s_mqtt_connection, &pub_opts);

    ESP_LOGD(TAG_MQTT, "Sent offline status");
    vTaskDelay(pdMS_TO_TICKS(500)); // Give time to send
  }
}

// Heartbeat callback - sends status every 30 seconds (more frequent for better detection)
static void heartbeat_callback(void *arg) {
  if (s_mqtt_connection != NULL) {
    ESP_LOGD(TAG_HB, "Heartbeat");
    publish_status(s_mqtt_connection);
  }
}

// Initialize heartbeat timer - call this in app_main() after mongoose_init()
static void heartbeat_init(void) {
  esp_timer_create_args_t timer_args = {
    .callback = &heartbeat_callback,
    .arg = NULL,
    .name = "heartbeat"
  };
  
  esp_timer_create(&timer_args, &s_heartbeat_timer);
  
  // Send heartbeat every 30 seconds
  // Combined with MQTT keepalive (60s), dashboard will detect offline within 90s
  esp_timer_start_periodic(s_heartbeat_timer, 30 * 1000000ULL); // 30 seconds

  ESP_LOGD(TAG_HB, "Heartbeat initialized (30s interval)");
}


static esp_err_t init_camera(int framesize) {
  // initialize the camera
  camera_config.frame_size = framesize;
  esp_err_t err = esp_camera_init(&camera_config);
  if (err != ESP_OK) {
    ESP_LOGE(TAG, "Camera Init Failed");
    return err;
  }

  // Optimize camera for distant objects in sunny conditions
  sensor_t *s = esp_camera_sensor_get();
  if (s != NULL) {
    // White balance for sunny outdoor conditions
    s->set_whitebal(s, 1);   // Enable AWB
    s->set_awb_gain(s, 1);   // Enable AWB gain
    s->set_wb_mode(s, 1);    // Sunny mode (1=sunny, better for outdoor)
    s->set_saturation(s, 1); // Slightly increase saturation for clarity

    // Excellent quality JPEG compression (balanced)
    s->set_quality(s, 8); // Excellent quality, stable (8 = sweet spot)
    // s->set_quality(s, 10); // Excellent quality, stable (8 = sweet spot)
    // s->set_quality(s, 12); // Excellent quality, stable (8 = sweet spot)

    // Sharpness and detail enhancement for distant objects
    s->set_sharpness(s, 2); // Increase sharpness
    s->set_denoise(s, 0);   // Disable denoise to preserve fine detail

    // Exposure and gain for bright sunny conditions
    s->set_aec_value(s, 400); // Lower exposure for bright light
    s->set_aec2(s, 0);        // Disable night mode
    s->set_ae_level(s, -1);   // Slightly underexpose to avoid overexposure
    s->set_agc_gain(s, 0);    // Lower gain for bright conditions

    // Lens and pixel corrections
    s->set_lenc(s, 1);           // Enable lens correction
    s->set_special_effect(s, 0); // No special effects
    s->set_bpc(s, 1);            // Black pixel correction
    s->set_wpc(s, 1);            // White pixel correction

    // Contrast for better clarity of distant objects
    s->set_contrast(s, 1); // Slightly increase contrast

    ESP_LOGI(TAG, "Camera optimized: sunny/distant objects mode");
    vTaskDelay(pdMS_TO_TICKS(500)); // Allow settings to stabilize
    camera_initialized = true;
  }

  return ESP_OK;
}

// Simple base64 encoding (you'll need this for MQTT transmission)
static const char base64_chars[] = 
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

static char* base64_encode(const unsigned char *data, size_t input_length, size_t *output_length) {
    *output_length = 4 * ((input_length + 2) / 3);
    
    char *encoded_data = malloc(*output_length + 1);
    if (encoded_data == NULL) return NULL;

    for (size_t i = 0, j = 0; i < input_length;) {
        uint32_t octet_a = i < input_length ? data[i++] : 0;
        uint32_t octet_b = i < input_length ? data[i++] : 0;
        uint32_t octet_c = i < input_length ? data[i++] : 0;

        uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;

        encoded_data[j++] = base64_chars[(triple >> 3 * 6) & 0x3F];
        encoded_data[j++] = base64_chars[(triple >> 2 * 6) & 0x3F];
        encoded_data[j++] = base64_chars[(triple >> 1 * 6) & 0x3F];
        encoded_data[j++] = base64_chars[(triple >> 0 * 6) & 0x3F];
    }

    for (size_t i = 0; i < (3 - input_length % 3) % 3; i++)
        encoded_data[*output_length - 1 - i] = '=';

    encoded_data[*output_length] = '\0';
    return encoded_data;
}

static void capture_and_send_photo(struct mg_connection *c) {
    ESP_LOGI(TAG, "ðŸ“¸ Camera photo requested");
    
    // Check if camera is initialized
    if (!camera_initialized) {
        ESP_LOGE(TAG, "Camera not initialized - cannot capture");
        
        // Send error response to simcam status topic
        char response[256];
        snprintf(response, sizeof(response),
            "Camera not initialized");
        
        char status_topic[100];
        struct mg_mqtt_opts pub_opts;
        memset(&pub_opts, 0, sizeof(pub_opts));
        mg_snprintf(status_topic, sizeof(status_topic), "simcam/%s/status", CONFIG_DEVICE_ID);
        pub_opts.topic = mg_str(status_topic);
        pub_opts.message = mg_str(response);
        pub_opts.qos = 1;
        mg_mqtt_pub(c, &pub_opts);
        return;
    }

    // Flush old frames
    ESP_LOGI(TAG, "Flushing camera buffer...");
    camera_fb_t *flush_fb = NULL;
    int flushed = 0;
    do {
        flush_fb = esp_camera_fb_get();
        if (flush_fb) {
            esp_camera_fb_return(flush_fb);
            flushed++;
        }
    } while (flush_fb != NULL && flushed < 5);

    vTaskDelay(pdMS_TO_TICKS(300));

    // Capture fresh frame
    ESP_LOGI(TAG, "Capturing image...");
    camera_fb_t *fb = esp_camera_fb_get();
    
    if (!fb) {
        ESP_LOGW(TAG, "First capture failed, retrying...");
        vTaskDelay(pdMS_TO_TICKS(1000));
        fb = esp_camera_fb_get();
    }

    if (fb) {
        ESP_LOGI(TAG, "Captured image: %d bytes", fb->len);
        
        // Publish raw JPEG bytes directly to simcam topic (same as camera project)
        char pub_topic[100];
        struct mg_mqtt_opts pub_opts;
        memset(&pub_opts, 0, sizeof(pub_opts));
        
        mg_snprintf(pub_topic, sizeof(pub_topic), "simcam/%s", CONFIG_DEVICE_ID);
        pub_opts.topic = mg_str(pub_topic);
        pub_opts.message = mg_str_n((char *)fb->buf, fb->len);
        pub_opts.qos = 1;
        mg_mqtt_pub(c, &pub_opts);
        
        ESP_LOGI(TAG, "Camera image sent via MQTT to %s", pub_topic);
        
        // Return frame buffer immediately after publishing
        esp_camera_fb_return(fb);
        fb = NULL;
        
        // Send success status
        char status_msg[128];
        snprintf(status_msg, sizeof(status_msg), "Photo success: MQTT=OK");
        
        char status_topic[100];
        memset(&pub_opts, 0, sizeof(pub_opts));
        mg_snprintf(status_topic, sizeof(status_topic), "simcam/%s/status", CONFIG_DEVICE_ID);
        pub_opts.topic = mg_str(status_topic);
        pub_opts.message = mg_str(status_msg);
        pub_opts.qos = 1;
        mg_mqtt_pub(c, &pub_opts);
        
    } else {
        ESP_LOGE(TAG, "Camera capture failed");
        
        // Send failure status to simcam status topic
        char status_topic[100];
        struct mg_mqtt_opts pub_opts;
        memset(&pub_opts, 0, sizeof(pub_opts));
        mg_snprintf(status_topic, sizeof(status_topic), "simcam/%s/status", CONFIG_DEVICE_ID);
        pub_opts.topic = mg_str(status_topic);
        pub_opts.message = mg_str("Photo failed: Camera capture failed");
        pub_opts.qos = 1;
        mg_mqtt_pub(c, &pub_opts);
    }
}


void app_main() {

  // esp_log_level_set("TAG_SCHED", ESP_LOG_DEBUG);
  // esp_log_level_set("TAG_OTA", ESP_LOG_DEBUG);
  // esp_log_level_set("TAG_MQTT", ESP_LOG_DEBUG);
  // esp_log_level_set("TAG_RPC", ESP_LOG_DEBUG);
  // esp_log_level_set("TAG", ESP_LOG_DEBUG);
  // esp_log_level_set("TAG_HB", ESP_LOG_DEBUG);
  //esp_log_level_set("SIM", ESP_LOG_DEBUG);

    ESP_LOGI(TAG, "v%s", PROJECT_VERSION);

  s_boot_time = 0;
  esp_vfs_spiffs_conf_t conf = {
    .base_path = "/spiffs",
    .max_files = 20,
    .format_if_mount_failed = true,
  };
  esp_vfs_spiffs_register(&conf);

  gpio_config_t io_conf = {.pin_bit_mask =
                               (1ULL << PUMP_ON_GPIO) | (1ULL << PUMP_OFF_GPIO),
                           .mode = GPIO_MODE_OUTPUT,
                           .pull_down_en = 0,
                           .pull_up_en = 0,
                           .intr_type = GPIO_INTR_DISABLE};
  gpio_config(&io_conf);
 
  gpio_set_level(PUMP_ON_GPIO, 0);
  gpio_set_level(PUMP_OFF_GPIO, 0);
  vTaskDelay(pdMS_TO_TICKS(1000));


    esp_err_t ret = sim_init();
  if (ret != ESP_OK) {
    ESP_LOGE(TAG, "SIM initialization failed");
    // System cannot work without network in SIM mode
    while (1) {
      vTaskDelay(pdMS_TO_TICKS(1000));
    }
  }else{
    ESP_LOGI(TAG, "SIM initialization succesful");
  }


  mongoose_init();
  scheduler_init();
  heartbeat_init();

  sntp_setoperatingmode(SNTP_OPMODE_POLL);
  sntp_setservername(0, "pool.ntp.org");
  sntp_init();

  // Wait for time sync
  time_t now = 0;
  struct tm timeinfo = { 0 };
  int retry = 0;
  while (timeinfo.tm_year < (2016 - 1900) && ++retry < 10) {
    vTaskDelay(pdMS_TO_TICKS(2000));
    time(&now);
    localtime_r(&now, &timeinfo);
  }

  if (timeinfo.tm_year < (2016 - 1900)) {
    ESP_LOGE(TAG,"âŒ Failed to sync time\n");
    s_boot_time = 0;  // Fallback to 0 if time sync fails
  } else {
    ESP_LOGD(TAG,"âœ… Time synced: %s", asctime(&timeinfo));
    s_boot_time = (int64_t)now;  // Record actual boot time
    ESP_LOGI(TAG,"ðŸ“… Boot time recorded: %lld", s_boot_time);
  }




  esp_task_wdt_config_t wdt_config = {
    .timeout_ms = 15000,  // 15 seconds
    .idle_core_mask = 0,
    .trigger_panic = true
  };
  esp_task_wdt_init(&wdt_config);
  esp_task_wdt_add(NULL);

#if CONFIG_ENABLE_CAMERA
  
      #if CONFIG_FRAMESIZE_240X240
        int framesize = FRAMESIZE_240X240;
      #define FRAMESIZE_STRING "240x240"
      #elif CONFIG_FRAMESIZE_QVGA
        int framesize = FRAMESIZE_QVGA;
      #define FRAMESIZE_STRING "320x240"
      #elif CONFIG_FRAMESIZE_HVGA
        int framesize = FRAMESIZE_HVGA;
      #define FRAMESIZE_STRING "480x320"
      #elif CONFIG_FRAMESIZE_VGA
        int framesize = FRAMESIZE_VGA;
      #define FRAMESIZE_STRING "640x480"
      #elif CONFIG_FRAMESIZE_SVGA
        int framesize = FRAMESIZE_SVGA;
      #define FRAMESIZE_STRING "800x600"
      #elif CONFIG_FRAMESIZE_XGA
        int framesize = FRAMESIZE_XGA;
      #define FRAMESIZE_STRING "1024x768"
      #elif CONFIG_FRAMESIZE_HD
        int framesize = FRAMESIZE_HD;
      #define FRAMESIZE_STRING "1280x720"
      #elif CONFIG_FRAMESIZE_SXGA
        int framesize = FRAMESIZE_SXGA;
      #define FRAMESIZE_STRING "1280x1024"
      #elif CONFIG_FRAMESIZE_UXGA
        int framesize = FRAMESIZE_UXGA;
      #define FRAMESIZE_STRING "1600x1200"
      #elif CONFIG_FRAMESIZE_QXGA
        int framesize = FRAMESIZE_QXGA;
      #define FRAMESIZE_STRING "2048x1536"
      #elif CONFIG_FRAMESIZE_QSXGA
        int framesize = FRAMESIZE_QSXGA;
      #define FRAMESIZE_STRING "2560x1920"
      #elif CONFIG_FRAMESIZE_5MP
        int framesize = FRAMESIZE_5MP;
      #define FRAMESIZE_STRING "2592x1944"
      #endif

          ESP_LOGI(TAG, "Initializing camera...");
          ret = init_camera(framesize);
          if (ret != ESP_OK) {
          while (1) {
            vTaskDelay(1);
            }
           }
#endif

  const esp_partition_t *ota_part = esp_ota_get_next_update_partition(NULL);
  //printf("OTA ready: %s (%lu KB)\n", ota_part->label, ota_part->size/1024);
  

  struct mongoose_mqtt_handlers mqtt_handlers = {
    .connect_fn = my_mqtt_connect,
    .on_connect_fn = my_mqtt_on_connect,
    .on_message_fn = my_mqtt_on_message,
    .on_cmd_fn = NULL,
  };
  mongoose_set_mqtt_handlers(&mqtt_handlers);

  ESP_LOGD(TAG,"MQTT handlers set. Starting main loop...\n");
  for (;;) {
    mongoose_poll();
    esp_task_wdt_reset();      // ðŸ”§ FIX: Reset watchdog every loop
    vTaskDelay(pdMS_TO_TICKS(10));  // Yield CPU
  }
}

