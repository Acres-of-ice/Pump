// SPDX-FileCopyrightText: 2024 Cesanta Software Limited
// SPDX-License-Identifier: GPL-2.0-only or commercial
// Generated by Mongoose Wizard, https://mongoose.ws/wizard/

#include "mongoose_glue.h"
#include "esp_spiffs.h"
#include "driver/gpio.h"

#include "esp_ota_ops.h"
#include "esp_partition.h"

#include "esp_task_wdt.h"
#include "esp_log.h"

#include <inttypes.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>

#include "sim.h"

#include "esp_timer.h"
#include "esp_sntp.h"
#include <time.h>
#include <sys/time.h>

static bool s_ota_active = false;
// static esp_ota_handle_t s_ota_handle = 0;

// Determine pump type from Kconfig
#if defined(CONFIG_Borewell)
    #define PUMP_TYPE "Borewell"
#elif defined(CONFIG_1HP)
    #define PUMP_TYPE "1 HP"
#else
    #define PUMP_TYPE "Unknown"
#endif


extern char imsi_number[16];

#define LED_GPIO GPIO_NUM_8

#define PUMP_ON_GPIO  GPIO_NUM_39    
#define PUMP_OFF_GPIO GPIO_NUM_41   


static const char *TAG = "PUMP";
static const char *TAG_MQTT = "MG_MQTT";
static const char *TAG_SCHED = "MG_SCHED";
static const char *TAG_OTA = "MG_OTA";
static const char *TAG_RPC = "MG_RPC";
static const char *TAG_HB = "MG_HB";


extern void wifi_init(const char *ssid, const char *pass);

static esp_timer_handle_t s_heartbeat_timer = NULL;

#define TLS_CA ""


#define PROJECT_VERSION "0.0.0"  


static struct mg_rpc *s_rpc = NULL;
static uint8_t s_qos = 1;
static char s_device_id[40];

#define DEVICE_ID CONFIG_SITE_NAME
static const char *s_topic_prefix = "pump";

static esp_ota_handle_t s_ota_handle = 0;
static bool s_ota_in_progress = false;

static struct mg_connection *s_mqtt_conn = NULL;

static struct mg_connection *s_mqtt_connection = NULL;

// Add these after your existing global variables
static int64_t s_boot_time = 0;  // Boot timestamp in seconds
static char s_imsi[20] = "Unknown";  // IMSI number from SIM

struct device_state {
  bool pump_status;            // true = ON, false = OFF
  char firmware_version[20];
};
static struct device_state s_device_state = {false, PROJECT_VERSION};

// Scheduler structures
#define MAX_SCHEDULES 10

typedef struct {
  uint32_t id;           // Unique schedule ID
  int64_t start_time;    // Unix timestamp (seconds)
  uint32_t duration;     // Duration in seconds
  uint32_t interval;     // Repeat interval in seconds (0 = one-time)
  bool enabled;          // Is schedule active?
  int64_t last_run;      // Last execution time
} pump_schedule_t;

static pump_schedule_t s_schedules[MAX_SCHEDULES];
static int s_schedule_count = 0;
static esp_timer_handle_t s_scheduler_timer = NULL;


static void scheduler_check_callback(void *arg);
static void pump_turn_on(uint32_t duration_seconds);
static void pump_turn_off_callback(void *arg);


static char *make_topic_name(char *buf, size_t len, const char *suffix) {
  mg_snprintf(buf, len, "%s/%s/%s", s_topic_prefix, CONFIG_DEVICE_ID, suffix);
  return buf;
}


static void publish_status(struct mg_connection *c) {
  char topic[100];
  char json[256];
  struct mg_mqtt_opts pub_opts;
  
  snprintf(json, sizeof(json),
    "{\"method\":\"status.notify\",\"params\":{\"status\":\"online\","
    "\"pump_status\":%s,\"firmware_version\":\"%s\"}}",
    s_device_state.pump_status ? "true" : "false", 
    s_device_state.firmware_version);

  memset(&pub_opts, 0, sizeof(pub_opts));
  pub_opts.topic = mg_str(make_topic_name(topic, sizeof(topic), "status"));
  pub_opts.message = mg_str(json);
  pub_opts.qos = s_qos;
  pub_opts.retain = false;  // âœ… CHANGE: Don't retain heartbeats
  mg_mqtt_pub(c, &pub_opts);
}


// Get current Unix timestamp
static int64_t get_current_timestamp(void) {
  struct timeval tv;
  gettimeofday(&tv, NULL);
  return (int64_t)tv.tv_sec;
}

// Turn pump ON for a specific duration
static void pump_turn_on(uint32_t duration_seconds) {
  ESP_LOGI(TAG_SCHED, "Turning pump ON for %lu seconds", duration_seconds);
  
  s_device_state.pump_status = true;

  #ifdef CONFIG_BORWELL
    gpio_set_level(PUMP_ON_GPIO, 0);
    gpio_set_level(PUMP_OFF_GPIO, 1);

    vTaskDelay(pdMS_TO_TICKS(5000));

    gpio_set_level(PUMP_ON_GPIO, 0);
    gpio_set_level(PUMP_OFF_GPIO, 0);
  #endif

  #ifdef CONFIG_1HP
    gpio_set_level(PUMP_ON_GPIO, 1);
  #endif

  
  // Publish status update
  if (s_mqtt_connection) {
    publish_status(s_mqtt_connection);
  }
  
  // Create one-shot timer to turn OFF after duration
  esp_timer_handle_t off_timer;
  esp_timer_create_args_t off_timer_args = {
    .callback = &pump_turn_off_callback,
    .arg = NULL,
    .name = "pump_off"
  };
  
  esp_timer_create(&off_timer_args, &off_timer);
  esp_timer_start_once(off_timer, duration_seconds * 1000000ULL);
}

// Timer callback to turn pump OFF
static void pump_turn_off_callback(void *arg) {
  ESP_LOGI(TAG_SCHED, "Turning pump OFF (duration expired)");
  
  s_device_state.pump_status = false;
  #ifdef CONFIG_BORWELL
    gpio_set_level(PUMP_ON_GPIO, 1);
    gpio_set_level(PUMP_OFF_GPIO, 0);

    vTaskDelay(pdMS_TO_TICKS(5000));

    gpio_set_level(PUMP_ON_GPIO, 0);
    gpio_set_level(PUMP_OFF_GPIO, 0);
  #endif

  #ifdef CONFIG_1HP
    gpio_set_level(PUMP_ON_GPIO, 0);
  #endif
  // Publish status update
  if (s_mqtt_connection) {
    publish_status(s_mqtt_connection);
  }
}

// Check all schedules and execute if needed
static void scheduler_check_callback(void *arg) {
  int64_t now = get_current_timestamp();
  
  for (int i = 0; i < s_schedule_count; i++) {
    pump_schedule_t *sched = &s_schedules[i];
    
    if (!sched->enabled) continue;
    
    // Check if it's time to run this schedule
    bool should_run = false;
    
    if (sched->interval == 0) {
      // One-time schedule
      if (now >= sched->start_time && sched->last_run == 0) {
        should_run = true;
      }
    } else {
      // Recurring schedule
      if (now >= sched->start_time) {
        int64_t time_since_last = now - sched->last_run;
        
        if (sched->last_run == 0 || time_since_last >= sched->interval) {
          should_run = true;
        }
      }
    }
    
    if (should_run) {
      ESP_LOGI(TAG_SCHED, "Executing schedule ID %lu", sched->id);
      sched->last_run = now;
      pump_turn_on(sched->duration);
      
      // Disable one-time schedules after execution
      if (sched->interval == 0) {
        sched->enabled = false;
      }
    }
  }
}

// Initialize scheduler
static void scheduler_init(void) {
  // Create periodic timer that checks every 10 seconds
  esp_timer_create_args_t timer_args = {
    .callback = &scheduler_check_callback,
    .arg = NULL,
    .name = "scheduler"
  };
  
  esp_timer_create(&timer_args, &s_scheduler_timer);
  esp_timer_start_periodic(s_scheduler_timer, 10 * 1000000); // 10 seconds

  ESP_LOGI(TAG_SCHED, "Scheduler initialized (10s check interval)");
}

// Add a new schedule
static void rpc_schedule_add(struct mg_rpc_req *r) {
  if (s_schedule_count >= MAX_SCHEDULES) {
    char response[128];
    snprintf(response, sizeof(response), "{\"id\":null,\"error\":\"Maximum schedules reached\"}");

    if (s_mqtt_connection) {
      char topic[100];
      struct mg_mqtt_opts pub_opts;
      memset(&pub_opts, 0, sizeof(pub_opts));
      pub_opts.topic = mg_str(make_topic_name(topic, sizeof(topic), "tx"));
      pub_opts.message = mg_str(response);
      pub_opts.qos = 1;
      mg_mqtt_pub(s_mqtt_connection, &pub_opts);
    }
    return;
  }

  // Parse and validate inputs
  int64_t start_time = mg_json_get_long(r->frame, "$.params.start", 0);
  int64_t duration = mg_json_get_long(r->frame, "$.params.duration", 0);
  int64_t interval = mg_json_get_long(r->frame, "$.params.interval", 0);

  // Validation: start_time must be positive (valid Unix timestamp)
  if (start_time <= 0) {
    char response[128];
    snprintf(response, sizeof(response), "{\"id\":null,\"error\":\"Invalid start_time: must be positive\"}");
    if (s_mqtt_connection) {
      char topic[100];
      struct mg_mqtt_opts pub_opts;
      memset(&pub_opts, 0, sizeof(pub_opts));
      pub_opts.topic = mg_str(make_topic_name(topic, sizeof(topic), "tx"));
      pub_opts.message = mg_str(response);
      pub_opts.qos = 1;
      mg_mqtt_pub(s_mqtt_connection, &pub_opts);
    }
    return;
  }

  // Validation: duration must be between 1 second and 24 hours (86400 seconds)
  if (duration <= 0 || duration > 86400) {
    char response[128];
    snprintf(response, sizeof(response), "{\"id\":null,\"error\":\"Invalid duration: must be 1-86400 seconds\"}");
    if (s_mqtt_connection) {
      char topic[100];
      struct mg_mqtt_opts pub_opts;
      memset(&pub_opts, 0, sizeof(pub_opts));
      pub_opts.topic = mg_str(make_topic_name(topic, sizeof(topic), "tx"));
      pub_opts.message = mg_str(response);
      pub_opts.qos = 1;
      mg_mqtt_pub(s_mqtt_connection, &pub_opts);
    }
    return;
  }

  // Validation: interval must be 0 (one-time) or at least equal to duration
  if (interval < 0 || (interval > 0 && interval < duration)) {
    char response[128];
    snprintf(response, sizeof(response), "{\"id\":null,\"error\":\"Invalid interval: must be 0 or >= duration\"}");
    if (s_mqtt_connection) {
      char topic[100];
      struct mg_mqtt_opts pub_opts;
      memset(&pub_opts, 0, sizeof(pub_opts));
      pub_opts.topic = mg_str(make_topic_name(topic, sizeof(topic), "tx"));
      pub_opts.message = mg_str(response);
      pub_opts.qos = 1;
      mg_mqtt_pub(s_mqtt_connection, &pub_opts);
    }
    return;
  }

  pump_schedule_t *sched = &s_schedules[s_schedule_count];

  sched->id = mg_json_get_long(r->frame, "$.params.id", 0);
  sched->start_time = start_time;
  sched->duration = (uint32_t)duration;
  sched->interval = (uint32_t)interval;
  mg_json_get_bool(r->frame, "$.params.enabled", &sched->enabled);
  sched->last_run = 0;

  s_schedule_count++;

  ESP_LOGI(TAG_SCHED, "Added schedule: ID=%lu, Start=%lld, Duration=%lu, Interval=%lu",
           sched->id, sched->start_time, sched->duration, sched->interval);
  
  // Send success response
  char response[128];
  snprintf(response, sizeof(response), "{\"id\":null,\"result\":\"ok\"}");
  
  if (s_mqtt_connection) {
    char topic[100];
    struct mg_mqtt_opts pub_opts;
    memset(&pub_opts, 0, sizeof(pub_opts));
    pub_opts.topic = mg_str(make_topic_name(topic, sizeof(topic), "tx"));
    pub_opts.message = mg_str(response);
    pub_opts.qos = 1;
    mg_mqtt_pub(s_mqtt_connection, &pub_opts);
  }
}

// Delete a schedule
static void rpc_schedule_delete(struct mg_rpc_req *r) {
  uint32_t id = mg_json_get_long(r->frame, "$.params.id", 0);
  
  for (int i = 0; i < s_schedule_count; i++) {
    if (s_schedules[i].id == id) {
      // Shift remaining schedules
      for (int j = i; j < s_schedule_count - 1; j++) {
        s_schedules[j] = s_schedules[j + 1];
      }
      s_schedule_count--;

      ESP_LOGI(TAG_SCHED, "Deleted schedule ID %lu", id);
      
      // Send response
      char response[128];
      snprintf(response, sizeof(response), "{\"id\":null,\"result\":\"ok\"}");
      
      if (s_mqtt_connection) {
        char topic[100];
        struct mg_mqtt_opts pub_opts;
        memset(&pub_opts, 0, sizeof(pub_opts));
        pub_opts.topic = mg_str(make_topic_name(topic, sizeof(topic), "tx"));
        pub_opts.message = mg_str(response);
        pub_opts.qos = 1;
        mg_mqtt_pub(s_mqtt_connection, &pub_opts);
      }
      return;
    }
  }
  
  // Not found
  char response[128];
  snprintf(response, sizeof(response), "{\"id\":null,\"error\":\"Schedule not found\"}");
  
  if (s_mqtt_connection) {
    char topic[100];
    struct mg_mqtt_opts pub_opts;
    memset(&pub_opts, 0, sizeof(pub_opts));
    pub_opts.topic = mg_str(make_topic_name(topic, sizeof(topic), "tx"));
    pub_opts.message = mg_str(response);
    pub_opts.qos = 1;
    mg_mqtt_pub(s_mqtt_connection, &pub_opts);
  }
}

// Toggle schedule enabled/disabled
static void rpc_schedule_toggle(struct mg_rpc_req *r) {
  uint32_t id = mg_json_get_long(r->frame, "$.params.id", 0);
  bool enabled = false;
  mg_json_get_bool(r->frame, "$.params.enabled", &enabled);
  
  for (int i = 0; i < s_schedule_count; i++) {
    if (s_schedules[i].id == id) {
      s_schedules[i].enabled = enabled;
      ESP_LOGI(TAG_SCHED, "Schedule ID %lu %s", id, enabled ? "enabled" : "disabled");
      
      // Send response
      char response[128];
      snprintf(response, sizeof(response), "{\"id\":null,\"result\":\"ok\"}");
      
      if (s_mqtt_connection) {
        char topic[100];
        struct mg_mqtt_opts pub_opts;
        memset(&pub_opts, 0, sizeof(pub_opts));
        pub_opts.topic = mg_str(make_topic_name(topic, sizeof(topic), "tx"));
        pub_opts.message = mg_str(response);
        pub_opts.qos = 1;
        mg_mqtt_pub(s_mqtt_connection, &pub_opts);
      }
      return;
    }
  }
  
  // Not found
  char response[128];
  snprintf(response, sizeof(response), "{\"id\":null,\"error\":\"Schedule not found\"}");
  
  if (s_mqtt_connection) {
    char topic[100];
    struct mg_mqtt_opts pub_opts;
    memset(&pub_opts, 0, sizeof(pub_opts));
    pub_opts.topic = mg_str(make_topic_name(topic, sizeof(topic), "tx"));
    pub_opts.message = mg_str(response);
    pub_opts.qos = 1;
    mg_mqtt_pub(s_mqtt_connection, &pub_opts);
  }
}

// List all schedules
static void rpc_schedule_list(struct mg_rpc_req *r) {
  char json[1024];
  int offset = 0;
  
  offset += snprintf(json + offset, sizeof(json) - offset,
                     "{\"id\":null,\"result\":{\"schedules\":[");
  
  for (int i = 0; i < s_schedule_count; i++) {
    pump_schedule_t *s = &s_schedules[i];
    offset += snprintf(json + offset, sizeof(json) - offset,
                       "%s{\"id\":%lu,\"start\":%lld,\"duration\":%lu,"
                       "\"interval\":%lu,\"enabled\":%s,\"last_run\":%lld}",
                       i > 0 ? "," : "",
                       s->id, s->start_time, s->duration,
                       s->interval, s->enabled ? "true" : "false",
                       s->last_run);
  }
  
  offset += snprintf(json + offset, sizeof(json) - offset, "]}}");

  ESP_LOGI(TAG_SCHED, "Listing %d schedules", s_schedule_count);
  
  if (s_mqtt_connection) {
    char topic[100];
    struct mg_mqtt_opts pub_opts;
    memset(&pub_opts, 0, sizeof(pub_opts));
    pub_opts.topic = mg_str(make_topic_name(topic, sizeof(topic), "tx"));
    pub_opts.message = mg_str_n(json, offset);
    pub_opts.qos = 1;
    mg_mqtt_pub(s_mqtt_connection, &pub_opts);
  }
}


static void publish_response(struct mg_connection *c, char *buf, size_t len) {
  struct mg_mqtt_opts pub_opts;
  char topic[100];
  memset(&pub_opts, 0, sizeof(pub_opts));
  pub_opts.topic = mg_str(make_topic_name(topic, sizeof(topic), "tx"));
  pub_opts.message = mg_str_n(buf, len);
  pub_opts.qos = s_qos;
  mg_mqtt_pub(c, &pub_opts);
}

static void rpc_ota_upload(struct mg_rpc_req *r) {
  long ofs = mg_json_get_long(r->frame, "$.params.offset", -1);
  long tot = mg_json_get_long(r->frame, "$.params.total", -1);
  int len = 0;
  char *buf = mg_json_get_b64(r->frame, "$.params.chunk", &len);

  ESP_LOGI(TAG_OTA, "OTA chunk: offset=%ld total=%ld len=%d", ofs, tot, len);

  if (buf == NULL) {
    ESP_LOGE(TAG_OTA, "Buffer is NULL");
    mg_rpc_err(r, 1, "Error processing the binary chunk.");
  } else {
    bool success = true;

    if (ofs < 0 || tot < 0) {
      ESP_LOGE(TAG_OTA, "Invalid params");
      mg_rpc_err(r, 1, "offset and total not set");
      success = false;
    } else if (ofs == 0 && mg_ota_begin((size_t) tot) == false) {
      ESP_LOGE(TAG_OTA, "mg_ota_begin failed");
      mg_rpc_err(r, 1, "mg_ota_begin(%ld) failed", tot);
      mg_ota_end();
      success = false;
    } else if (len > 0 && mg_ota_write(buf, len) == false) {
      ESP_LOGE(TAG_OTA, "mg_ota_write failed");
      mg_rpc_err(r, 1, "mg_ota_write(%d) @%ld failed", len, ofs);
      mg_ota_end();
      success = false;
    } else if (ofs + len >= tot && mg_ota_end() == false) {
      ESP_LOGE(TAG_OTA, "mg_ota_end failed");
      mg_rpc_err(r, 1, "mg_ota_end() failed");
      success = false;
    }

    if (success) {
      ESP_LOGI(TAG_OTA, "Progress: %.1f%% (%ld/%ld)", (ofs + len) * 100.0 / tot, ofs + len, tot);
      mg_rpc_ok(r, "%m", MG_ESC("ok"));

      // If last chunk, reboot to apply new firmware
      if (ofs + len >= tot) {
        ESP_LOGI(TAG_OTA, "OTA COMPLETE! Rebooting in 2 seconds...");
        vTaskDelay(pdMS_TO_TICKS(2000));
        esp_restart();
      }
    }

    mg_free(buf);
  }
}
void my_mqtt_tls_init(struct mg_connection *c) {
  bool is_tls = mg_url_is_ssl(WIZARD_MQTT_URL);
  ESP_LOGD(TAG_MQTT, "Connection %lu TLS enabled: %s", c->id, is_tls ? "yes" : "no");
  if (is_tls) {
    struct mg_tls_opts opts = {0};
    opts.ca = mg_str(TLS_CA);
    opts.name = mg_url_host(WIZARD_MQTT_URL);
    mg_tls_init(c, &opts);
  }
}

void my_mqtt_on_connect(struct mg_connection *c, int code) {
  char topic[100];
  struct mg_mqtt_opts opts = {0};
  opts.qos = 1;
  opts.topic = mg_str(make_topic_name(topic, sizeof(topic), "rx"));
  mg_mqtt_sub(c, &opts);
  publish_status(c);
  ESP_LOGI(TAG_MQTT, "Connected (code %d), subscribed to rx topic", code);
}



void my_mqtt_on_message(struct mg_connection *c, struct mg_str topic, struct mg_str data) {
  char msg[512];  // Increased size for OTA messages
  int copy_len = (data.len < sizeof(msg) - 1) ? data.len : sizeof(msg) - 1;
  memcpy(msg, data.buf, copy_len);
  msg[copy_len] = '\0';

  ESP_LOGI(TAG_MQTT, "RX: %s", msg);

  // STATUS REQUEST - Reply with firmware version and site name
  if (strstr(msg, "status") != NULL || strstr(msg, "STATUS") != NULL) {
    ESP_LOGI(TAG_MQTT, "Status request received");
    
    // Calculate uptime
    int64_t current_time = get_current_timestamp();
    int64_t uptime_seconds = current_time - s_boot_time;
    int uptime_days = uptime_seconds / 86400;
    int uptime_hours = (uptime_seconds % 86400) / 3600;
    int uptime_minutes = (uptime_seconds % 3600) / 60;
    
    char uptime_str[64];
    if (uptime_days > 0) {
      snprintf(uptime_str, sizeof(uptime_str), "%d days, %d hours", uptime_days, uptime_hours);
    } else if (uptime_hours > 0) {
      snprintf(uptime_str, sizeof(uptime_str), "%d hours, %d minutes", uptime_hours, uptime_minutes);
    } else {
      snprintf(uptime_str, sizeof(uptime_str), "%d minutes", uptime_minutes);
    }
    
    char response[512];
    snprintf(response, sizeof(response),
      "{\"method\":\"status.response\",\"params\":{"
      "\"site_name\":\"%s\","
      "\"firmware_version\":\"%s\","
      "\"pump_type\":\"%s\"," 
      "\"pump_status\":\"%s\","
      "\"imsi\":\"%s\","
      "\"uptime\":\"%s\"}}",
      CONFIG_DEVICE_ID,
      s_device_state.firmware_version,
      PUMP_TYPE,
      s_device_state.pump_status ? "ON" : "OFF",
      imsi_number,
      uptime_str);
    
    // Publish response to tx topic
    char topic_tx[100];
    struct mg_mqtt_opts pub_opts;
    memset(&pub_opts, 0, sizeof(pub_opts));
    pub_opts.topic = mg_str(make_topic_name(topic_tx, sizeof(topic_tx), "tx"));
    pub_opts.message = mg_str(response);
    pub_opts.qos = 1;
    mg_mqtt_pub(c, &pub_opts);

    ESP_LOGI(TAG_MQTT, "Status response sent: Site=%s, FW=%s, Pump=%s, Uptime=%s",
             CONFIG_DEVICE_ID, s_device_state.firmware_version,
             s_device_state.pump_status ? "ON" : "OFF", uptime_str);
    return;
  }

  // DIRECT PUMP CONTROL - NO RPC LAYER!
  if (strstr(msg, "ON") != NULL) {
    ESP_LOGI(TAG, "PUMP ON triggered");
    s_device_state.pump_status = true;
  #ifdef CONFIG_BORWELL
    gpio_set_level(PUMP_ON_GPIO, 0);
    gpio_set_level(PUMP_OFF_GPIO, 1);
    // ESP_LOGI(TAG, "PUMP ON triggered Borewell");
    vTaskDelay(pdMS_TO_TICKS(5000));

    gpio_set_level(PUMP_ON_GPIO, 0);
    gpio_set_level(PUMP_OFF_GPIO, 0);
    ESP_LOGI(TAG, "PUMP OFF triggered Borewell");
  #endif

  #ifdef CONFIG_1HP
    gpio_set_level(PUMP_ON_GPIO, 1);
  #endif
    publish_status(c);
    return;
  }
  else if (strstr(msg, "OFF") != NULL) {
    ESP_LOGI(TAG, "PUMP OFF triggered");
    s_device_state.pump_status = false;
  #ifdef CONFIG_BORWELL
    gpio_set_level(PUMP_ON_GPIO, 1);
    gpio_set_level(PUMP_OFF_GPIO, 0);

    vTaskDelay(pdMS_TO_TICKS(5000));

    gpio_set_level(PUMP_ON_GPIO, 0);
    gpio_set_level(PUMP_OFF_GPIO, 0);
  #endif

  #ifdef CONFIG_1HP
    gpio_set_level(PUMP_ON_GPIO, 0);
  #endif
    publish_status(c);
    return;
  }
  
  // Let RPC handle other messages (OTA)
  ESP_LOGD(TAG_RPC, "Processing as RPC command...");
  struct mg_iobuf io = {0, 0, 0, 512};

  // Initialize frame separately to avoid struct initializer issues
  struct mg_str frame;
  frame.buf = data.buf;
  frame.len = data.len;

  struct mg_rpc_req rpc_req = {&s_rpc, NULL, mg_pfn_iobuf, &io, NULL, frame};

  ESP_LOGD(TAG_RPC, "Before mg_rpc_process: io.buf=%p io.len=%zu", io.buf, io.len);
  mg_rpc_process(&rpc_req);
  ESP_LOGD(TAG_RPC, "After mg_rpc_process: io.buf=%p io.len=%zu", io.buf, io.len);

  if (io.buf && io.len > 0) {
    ESP_LOGD(TAG_RPC, "Response: %.*s", (int)io.len, (char*)io.buf);
    publish_response(c, (char *) io.buf, io.len);
    ESP_LOGI(TAG_RPC, "RPC response published");
    publish_status(c);
  } else {
    ESP_LOGD(TAG_RPC, "No response in buffer (manual publish was used)");
  }

  mg_iobuf_free(&io);
}
struct mg_connection *my_mqtt_connect(mg_event_handler_t fn) {
  const char *url = WIZARD_MQTT_URL;
  char topic[100], message[200];
  struct mg_mqtt_opts opts;
  struct mg_connection *c;

  // Initialize opts to zero
  memset(&opts, 0, sizeof(opts));

  // âœ… ONLINE MESSAGE - Sent when device connects
  snprintf(message, sizeof(message),
    "{\"method\":\"status.notify\",\"params\":{\"status\":\"online\",\"pump_status\":%s,\"firmware_version\":\"%s\"}}",
    s_device_state.pump_status ? "true" : "false",
    s_device_state.firmware_version);

  // Basic MQTT options
  opts.clean = true;
  opts.qos = s_qos;
  opts.topic = mg_str(make_topic_name(topic, sizeof(topic), "status"));
  opts.version = 4;  // MQTT 3.1.1
  opts.retain = true;
  opts.message = mg_str(message);

  // âœ… MQTT Authentication - extract user/pass from URL
  opts.user = mg_url_user(url);
  opts.pass = mg_url_pass(url);

  // âœ… KEEP ALIVE - Critical for timeout detection!
  // Sends ping every 60 seconds, dashboard will detect offline if no ping received
  opts.keepalive = 20;
  
  // No LWT support in this Mongoose version
  // Dashboard will detect offline via timeout (90 seconds without heartbeat)

  // Register RPC handlers (only once)
  if (s_rpc == NULL) {
    mg_rpc_add(&s_rpc, mg_str("ota.upload"), rpc_ota_upload, NULL);
    mg_rpc_add(&s_rpc, mg_str("schedule.add"), rpc_schedule_add, NULL);
    mg_rpc_add(&s_rpc, mg_str("schedule.delete"), rpc_schedule_delete, NULL);
    mg_rpc_add(&s_rpc, mg_str("schedule.toggle"), rpc_schedule_toggle, NULL);
    mg_rpc_add(&s_rpc, mg_str("schedule.list"), rpc_schedule_list, NULL);
  }

  if ((c = mg_mqtt_connect(&g_mgr, url, &opts, fn, NULL)) != NULL) {
    ESP_LOGI(TAG_MQTT, "Connection %lu initiated with keepalive=%d", c->id, opts.keepalive);
  }
  return c;
}

// âœ… IMPORTANT: Add this function to handle graceful shutdown (optional)
// Call this if you want to send offline status before restart
void mqtt_send_offline_status(void) {
  if (s_mqtt_connection != NULL) {
    char topic[100];
    char json[256];
    struct mg_mqtt_opts pub_opts;
    
    snprintf(json, sizeof(json),
      "{\"method\":\"status.notify\",\"params\":{\"status\":\"offline\"}}");

    memset(&pub_opts, 0, sizeof(pub_opts));
    pub_opts.topic = mg_str(make_topic_name(topic, sizeof(topic), "status"));
    pub_opts.message = mg_str(json);
    pub_opts.qos = s_qos;
    pub_opts.retain = true;
    mg_mqtt_pub(s_mqtt_connection, &pub_opts);

    ESP_LOGI(TAG_MQTT, "Sent offline status");
    vTaskDelay(pdMS_TO_TICKS(500)); // Give time to send
  }
}

// Heartbeat callback - sends status every 30 seconds (more frequent for better detection)
static void heartbeat_callback(void *arg) {
  if (s_mqtt_connection != NULL) {
    ESP_LOGD(TAG_HB, "Heartbeat");
    publish_status(s_mqtt_connection);
  }
}

// Initialize heartbeat timer - call this in app_main() after mongoose_init()
static void heartbeat_init(void) {
  esp_timer_create_args_t timer_args = {
    .callback = &heartbeat_callback,
    .arg = NULL,
    .name = "heartbeat"
  };
  
  esp_timer_create(&timer_args, &s_heartbeat_timer);
  
  // Send heartbeat every 30 seconds
  // Combined with MQTT keepalive (60s), dashboard will detect offline within 90s
  esp_timer_start_periodic(s_heartbeat_timer, 30 * 1000000ULL); // 30 seconds

  ESP_LOGI(TAG_HB, "Heartbeat initialized (30s interval)");
}


void app_main() {

    ESP_LOGI(TAG, "v%s", PROJECT_VERSION);

  s_boot_time = 0;
  esp_vfs_spiffs_conf_t conf = {
    .base_path = "/spiffs",
    .max_files = 20,
    .format_if_mount_failed = true,
  };
  esp_vfs_spiffs_register(&conf);

  gpio_config_t io_conf = {.pin_bit_mask =
                               (1ULL << PUMP_ON_GPIO) | (1ULL << PUMP_OFF_GPIO),
                           .mode = GPIO_MODE_OUTPUT,
                           .pull_down_en = 0,
                           .pull_up_en = 0,
                           .intr_type = GPIO_INTR_DISABLE};
  gpio_config(&io_conf);
 
  gpio_set_level(PUMP_ON_GPIO, 1);
  gpio_set_level(PUMP_OFF_GPIO, 1);
  vTaskDelay(pdMS_TO_TICKS(1000));


    esp_err_t ret = sim_init();
  if (ret != ESP_OK) {
    ESP_LOGE(TAG, "SIM initialization failed");
    // System cannot work without network in SIM mode
    while (1) {
      vTaskDelay(pdMS_TO_TICKS(1000));
    }
  }else{
    ESP_LOGI(TAG, "SIM initialization succesful");
        // Get IMSI after SIM is initialized
    // vTaskDelay(pdMS_TO_TICKS(2000));  // Wait for SIM to be ready
    // get_imsi_from_sim();
  }


  mongoose_init();
  scheduler_init();
  heartbeat_init();

  sntp_setoperatingmode(SNTP_OPMODE_POLL);
  sntp_setservername(0, "pool.ntp.org");
  sntp_init();

  // Wait for time sync
  time_t now = 0;
  struct tm timeinfo = { 0 };
  int retry = 0;
  while (timeinfo.tm_year < (2016 - 1900) && ++retry < 10) {
    vTaskDelay(pdMS_TO_TICKS(2000));
    time(&now);
    localtime_r(&now, &timeinfo);
  }

  if (timeinfo.tm_year < (2016 - 1900)) {
    ESP_LOGE(TAG,"âŒ Failed to sync time\n");
    s_boot_time = 0;  // Fallback to 0 if time sync fails
  } else {
    ESP_LOGI(TAG,"âœ… Time synced: %s", asctime(&timeinfo));
    s_boot_time = (int64_t)now;  // Record actual boot time
    ESP_LOGI(TAG,"ðŸ“… Boot time recorded: %lld", s_boot_time);
  }


  esp_task_wdt_config_t wdt_config = {
    .timeout_ms = 15000,  // 15 seconds
    .idle_core_mask = 0,
    .trigger_panic = true
  };
  esp_task_wdt_init(&wdt_config);
  esp_task_wdt_add(NULL);

  const esp_partition_t *ota_part = esp_ota_get_next_update_partition(NULL);
  //printf("OTA ready: %s (%lu KB)\n", ota_part->label, ota_part->size/1024);
  

  struct mongoose_mqtt_handlers mqtt_handlers = {
    .connect_fn = my_mqtt_connect,
    .on_connect_fn = my_mqtt_on_connect,
    .on_message_fn = my_mqtt_on_message,
    .on_cmd_fn = NULL,
  };
  mongoose_set_mqtt_handlers(&mqtt_handlers);

  ESP_LOGI(TAG,"MQTT handlers set. Starting main loop...\n");
  for (;;) {
    mongoose_poll();
    esp_task_wdt_reset();      // ðŸ”§ FIX: Reset watchdog every loop
    vTaskDelay(pdMS_TO_TICKS(10));  // Yield CPU
  }
}
