// SPDX-FileCopyrightText: 2024 Cesanta Software Limited
// SPDX-License-Identifier: GPL-2.0-only or commercial
// Generated by Mongoose Wizard, https://mongoose.ws/wizard/

#include "mongoose_glue.h"
#include "esp_spiffs.h"
#include "driver/gpio.h"

#include "esp_ota_ops.h"
#include "esp_partition.h"

#include "esp_task_wdt.h"
#include "esp_log.h"

#include <inttypes.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>

#include "sim.h"

#define WIFI_SSID "Acres of Ice"
#define WIFI_PASS "UkDfPNEj5@"

static bool s_ota_active = false;
// static esp_ota_handle_t s_ota_handle = 0;

#define LED_GPIO GPIO_NUM_8

#define PUMP_ON_GPIO  GPIO_NUM_12    
#define PUMP_OFF_GPIO GPIO_NUM_13   


static const char *TAG = "PUMP";


extern void wifi_init(const char *ssid, const char *pass);

#define TLS_CA ""
#define FIRMWARE_VERSION "1.0.2"

static struct mg_rpc *s_rpc = NULL;
static uint8_t s_qos = 1;
static char s_device_id[40];
#define DEVICE_ID "Shey"
static const char *s_topic_prefix = "mg_mqtt_dashboard";

static esp_ota_handle_t s_ota_handle = 0;
static bool s_ota_in_progress = false;

static struct mg_connection *s_mqtt_conn = NULL;

struct device_state {
  bool pump_status;            // true = ON, false = OFF
  char firmware_version[20];
};
static struct device_state s_device_state = {false, FIRMWARE_VERSION};

// struct device_state {
//   bool led_status;
//   char firmware_version[20];
// };
// static struct device_state s_device_state = {false, FIRMWARE_VERSION};

// static char *make_topic_name(char *buf, size_t len, const char *suffix) {
//   if (s_device_id[0] == '\0') {
//     mg_snprintf(s_device_id, sizeof(s_device_id), "device_%llu", mg_now());
//   }
//   mg_snprintf(buf, len, "%s/%s/%s", s_topic_prefix, s_device_id, suffix);
//   return buf;
// }


static char *make_topic_name(char *buf, size_t len, const char *suffix) {
  // FIXED DEVICE ID - NO MORE AUTO-GENERATION!
  mg_snprintf(buf, len, "%s/%s/%s", s_topic_prefix, DEVICE_ID, suffix);
  return buf;
}

static void publish_response(struct mg_connection *c, char *buf, size_t len) {
  struct mg_mqtt_opts pub_opts;
  char topic[100];
  memset(&pub_opts, 0, sizeof(pub_opts));
  pub_opts.topic = mg_str(make_topic_name(topic, sizeof(topic), "tx"));
  pub_opts.message = mg_str_n(buf, len);
  pub_opts.qos = s_qos;
  mg_mqtt_pub(c, &pub_opts);
}

// FIXED: Manual JSON without mg_xprintf
static void publish_status(struct mg_connection *c) {
  char topic[100];
  char json[256];
  struct mg_mqtt_opts pub_opts;
  
  // Manual JSON formatting (safe, no mg_xprintf)
  snprintf(json, sizeof(json),
    "{\"method\":\"status.notify\",\"params\":{\"status\":\"online\","
    "\"pump_status\":%s,\"firmware_version\":\"%s\"}}",
    s_device_state.pump_status ? "true" : "false", 
    s_device_state.firmware_version);

  memset(&pub_opts, 0, sizeof(pub_opts));
  pub_opts.topic = mg_str(make_topic_name(topic, sizeof(topic), "status"));
  pub_opts.message = mg_str(json);
  pub_opts.qos = s_qos;
  pub_opts.retain = true;
  mg_mqtt_pub(c, &pub_opts);
}

static void rpc_state_set(struct mg_rpc_req *r) {
  // Access mg_str directly using .buf and .len (standard Mongoose)
  char msg[128];
  int copy_len = (r->frame.len < sizeof(msg) - 1) ? r->frame.len : sizeof(msg) - 1;
  memcpy(msg, r->frame.buf, copy_len);  // Use .buf not .ptr
  msg[copy_len] = '\0';
  
  printf("MQTT RX: %s\n", msg);
  
  // Standard C string matching
  if (strstr(msg, "PUMP ON") != NULL) {
    printf("üöø PUMP ON - GPIO42:1 GPIO43:0\n");
    s_device_state.pump_status = true;
    gpio_set_level(PUMP_ON_GPIO, 1);
    gpio_set_level(PUMP_OFF_GPIO, 0);
    
    // ‚úÖ VERIFY GPIO STATES
    printf("GPIO42: %d, GPIO43: %d\n", gpio_get_level(PUMP_ON_GPIO), gpio_get_level(PUMP_OFF_GPIO));
    
    mg_rpc_ok(r, "PUMP ON");
    
  } else if (strstr(msg, "PUMP OFF") != NULL) {
    printf("‚èπÔ∏è PUMP OFF - GPIO42:0 GPIO43:1\n");
    s_device_state.pump_status = false;
    gpio_set_level(PUMP_ON_GPIO, 0);
    gpio_set_level(PUMP_OFF_GPIO, 1);
    
    // ‚úÖ VERIFY GPIO STATES
    printf("GPIO42: %d, GPIO43: %d\n", gpio_get_level(PUMP_ON_GPIO), gpio_get_level(PUMP_OFF_GPIO));
    }else {
    mg_rpc_err(r, 2, "Commands: PUMP ON | PUMP OFF");
  }
}

// static void rpc_state_get(struct mg_rpc_req *r) {
//   char json[128];
//   snprintf(json, sizeof(json), 
//     "{\"pump_status\":%s}", 
//     s_device_state.pump_status ? "true" : "false");
//   mg_rpc_ok(r, "%s", json);
// }


static struct mg_connection *s_mqtt_connection = NULL;

static void rpc_ota_upload(struct mg_rpc_req *r) {
  long ofs = mg_json_get_long(r->frame, "$.params.offset", -1);
  long tot = mg_json_get_long(r->frame, "$.params.total", -1);
  int len = 0;
  char *buf = mg_json_get_b64(r->frame, "$.params.chunk", &len);
  
  printf("  üì• OTA: offset=%ld total=%ld len=%d\n", ofs, tot, len);
  
  if (buf == NULL) {
    printf("  ‚ùå buf is NULL\n");
    mg_rpc_err(r, 1, "Error processing the binary chunk.");
  } else {
    bool success = true;
    
    if (ofs < 0 || tot < 0) {
      printf("  ‚ùå Invalid params\n");
      mg_rpc_err(r, 1, "offset and total not set");
      success = false;
    } else if (ofs == 0 && mg_ota_begin((size_t) tot) == false) {
      printf("  ‚ùå mg_ota_begin failed\n");
      mg_rpc_err(r, 1, "mg_ota_begin(%ld) failed", tot);
      mg_ota_end();
      success = false;
    } else if (len > 0 && mg_ota_write(buf, len) == false) {
      printf("  ‚ùå mg_ota_write failed\n");
      mg_rpc_err(r, 1, "mg_ota_write(%d) @%ld failed", len, ofs);
      mg_ota_end();
      success = false;
    } else if (ofs + len >= tot && mg_ota_end() == false) {
      printf("  ‚ùå mg_ota_end failed\n");
      mg_rpc_err(r, 1, "mg_ota_end() failed");
      success = false;
    }
    
    if (success) {
      // ‚úÖ Success - manually publish response
      printf("  ‚úÖ Success: %.1f%% (%ld/%ld)\n", (ofs + len) * 100.0 / tot, ofs + len, tot);
      
      // Build JSON response manually
      char response[128];
      snprintf(response, sizeof(response), 
               "{\"id\":null,\"result\":\"ok\"}");
      
      printf("  üì§ Manual publish: %s\n", response);
      
      // Publish directly to tx topic
      if (s_mqtt_connection != NULL) {
        char topic[100];
        struct mg_mqtt_opts pub_opts;
        memset(&pub_opts, 0, sizeof(pub_opts));
        pub_opts.topic = mg_str(make_topic_name(topic, sizeof(topic), "tx"));
        pub_opts.message = mg_str(response);
        pub_opts.qos = 1;
        mg_mqtt_pub(s_mqtt_connection, &pub_opts);
        printf("  ‚úÖ Response published to %s\n", topic);
      } else {
        printf("  ‚ö†Ô∏è  No MQTT connection available!\n");
      }
      
      // Also call mg_rpc_ok for compatibility
      mg_rpc_ok(r, "%m", MG_ESC("ok"));
      
      // If last chunk
      if (ofs + len >= tot) {
        printf("  üéâ LAST CHUNK - OTA COMPLETE!\n");
        printf("  ‚è∞ Rebooting in 2 seconds...\n");
        vTaskDelay(pdMS_TO_TICKS(2000));
        esp_restart();
      }
    }
    
    mg_free(buf);
  }
}
void my_mqtt_tls_init(struct mg_connection *c) {
  bool is_tls = mg_url_is_ssl(WIZARD_MQTT_URL);
  MG_DEBUG(("%lu TLS enabled: %s", c->id, is_tls ? "yes" : "no"));
  if (is_tls) {
    struct mg_tls_opts opts = {0};
    opts.ca = mg_str(TLS_CA);
    opts.name = mg_url_host(WIZARD_MQTT_URL);
    mg_tls_init(c, &opts);
  }
}

void my_mqtt_on_connect(struct mg_connection *c, int code) {
  char topic[100];
  struct mg_mqtt_opts opts = {0};
  opts.qos = 1;
  opts.topic = mg_str(make_topic_name(topic, sizeof(topic), "rx"));
  mg_mqtt_sub(c, &opts);
  publish_status(c);
  MG_DEBUG(("%lu code %d. Subscribed to rx topic", c->id, code));
  printf("MQTT Connected! Visit https://mongoose.ws/mqtt-dashboard/\n");
}

// void my_mqtt_on_message(struct mg_connection *c, struct mg_str topic, struct mg_str data) {
//   struct mg_iobuf io = {0, 0, 0, 512};
//   struct mg_rpc_req r = {&s_rpc, NULL, mg_pfn_iobuf, &io, NULL, {data.buf, data.len}};
//   size_t clipped_len = data.len > 512 ? 512 : data.len;
  
//   printf("MQTT RX: %.*s <- %.*s\n", (int)topic.len, topic.buf, (int)clipped_len, data.buf);
  
//   mg_rpc_process(&r);
//   if (io.buf && io.len > 0) {
//     publish_response(c, (char *) io.buf, io.len);
//     publish_status(c);
//   }
//   mg_iobuf_free(&io);
// }

void my_mqtt_on_message(struct mg_connection *c, struct mg_str topic, struct mg_str data) {
  char msg[512];  // Increased size for OTA messages
  int copy_len = (data.len < sizeof(msg) - 1) ? data.len : sizeof(msg) - 1;
  memcpy(msg, data.buf, copy_len);
  msg[copy_len] = '\0';
  
  printf("\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n");
  printf("üì® MQTT RX: %s\n", msg);
  
  // Store connection globally for RPC functions to use
  s_mqtt_connection = c;
  
  // üî• DIRECT PUMP CONTROL - NO RPC LAYER!
  if (strstr(msg, "PUMP ON") != NULL) {
    printf("‚úÖ PUMP ON TRIGGERED!\n");
    s_device_state.pump_status = true;
    gpio_set_level(PUMP_ON_GPIO, 1);
    gpio_set_level(PUMP_OFF_GPIO, 0);
    printf("GPIO12=%d GPIO13=%d\n", gpio_get_level(PUMP_ON_GPIO), gpio_get_level(PUMP_OFF_GPIO));
    publish_status(c);
    printf("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n");
    return;
  } 
  else if (strstr(msg, "PUMP OFF") != NULL) {
    printf("‚úÖ PUMP OFF TRIGGERED!\n");
    s_device_state.pump_status = false;
    gpio_set_level(PUMP_ON_GPIO, 0);
    gpio_set_level(PUMP_OFF_GPIO, 1);
    printf("GPIO12=%d GPIO13=%d\n", gpio_get_level(PUMP_ON_GPIO), gpio_get_level(PUMP_OFF_GPIO));
    publish_status(c);
    printf("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n");
    return;
  }
  
  // Let RPC handle other messages (OTA)
  printf("üîÑ Processing as RPC command...\n");
  struct mg_iobuf io = {0, 0, 0, 512};
  
  // Initialize frame separately to avoid struct initializer issues
  struct mg_str frame;
  frame.buf = data.buf;
  frame.len = data.len;
  
  struct mg_rpc_req rpc_req = {&s_rpc, NULL, mg_pfn_iobuf, &io, NULL, frame};
  
  printf("üìç Before mg_rpc_process: io.buf=%p io.len=%zu\n", io.buf, io.len);
  mg_rpc_process(&rpc_req);
  printf("üìç After mg_rpc_process: io.buf=%p io.len=%zu\n", io.buf, io.len);
  
  if (io.buf && io.len > 0) {
    printf("üì§ Response buffer contains: %.*s\n", (int)io.len, (char*)io.buf);
    printf("üìÆ Publishing response to tx topic (backup method)...\n");
    publish_response(c, (char *) io.buf, io.len);
    printf("‚úÖ Response published!\n");
    publish_status(c);
  } else {
    printf("‚ö†Ô∏è  No response in buffer (manual publish was used)\n");
  }
  
  mg_iobuf_free(&io);
  printf("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n");
}
struct mg_connection *my_mqtt_connect(mg_event_handler_t fn) {
  const char *url = WIZARD_MQTT_URL;
  char topic[100], message[200];
  struct mg_mqtt_opts opts = {0};
  struct mg_connection *c;

  // Manual JSON for offline status
  snprintf(message, sizeof(message),
    "{\"method\":\"status.notify\",\"params\":{\"status\":\"offline\"}}");

  opts.clean = true;
  opts.qos = s_qos;
  opts.topic = mg_str(make_topic_name(topic, sizeof(topic), "status"));
  opts.version = 4;
  opts.retain = true;
  opts.message = mg_str(message);

  if (s_rpc == NULL) {
    // mg_rpc_add(&s_rpc, mg_str("state.set"), rpc_state_set, NULL);
    // mg_rpc_add(&s_rpc, mg_str("state.get"), rpc_state_get, NULL);
    mg_rpc_add(&s_rpc, mg_str("ota.upload"), rpc_ota_upload, NULL);
  }

  if ((c = mg_mqtt_connect(&g_mgr, url, &opts, fn, NULL)) != NULL) {
    MG_DEBUG(("%lu MQTT connect initiated", c->id));
  }
  return c;
}

void app_main() {
  esp_vfs_spiffs_conf_t conf = {
    .base_path = "/spiffs",
    .max_files = 20,
    .format_if_mount_failed = true,
  };
  esp_vfs_spiffs_register(&conf);

  // wifi_init(WIFI_SSID, WIFI_PASS);
  // printf("WiFi connected, initializing Mongoose...\n");

    esp_err_t ret = sim_init();
  if (ret != ESP_OK) {
    ESP_LOGE(TAG, "SIM initialization failed");
    // System cannot work without network in SIM mode
    while (1) {
      vTaskDelay(pdMS_TO_TICKS(1000));
    }
  }else{
    ESP_LOGI(TAG, "SIM initialization succesful");
  }

  mongoose_init();


  gpio_set_direction(LED_GPIO, GPIO_MODE_OUTPUT);
  gpio_set_level(LED_GPIO, 0);  // LED OFF initially

  gpio_set_direction(PUMP_ON_GPIO, GPIO_MODE_OUTPUT);
  gpio_set_direction(PUMP_OFF_GPIO, GPIO_MODE_OUTPUT);
  gpio_set_level(PUMP_ON_GPIO, 0);   // Pump OFF initially
  gpio_set_level(PUMP_OFF_GPIO, 0);  // Safety ON initially

  esp_task_wdt_config_t wdt_config = {
    .timeout_ms = 15000,  // 15 seconds
    .idle_core_mask = 0,
    .trigger_panic = true
  };
  esp_task_wdt_init(&wdt_config);
  esp_task_wdt_add(NULL);

const esp_partition_t *ota_part = esp_ota_get_next_update_partition(NULL);
printf("OTA ready: %s (%lu KB)\n", ota_part->label, ota_part->size/1024);


  struct mongoose_mqtt_handlers mqtt_handlers = {
    my_mqtt_connect,
    my_mqtt_on_connect,
    my_mqtt_on_message,
  };
  mongoose_set_mqtt_handlers(&mqtt_handlers);

  printf("MQTT handlers set. Starting main loop...\n");
  for (;;) {
    mongoose_poll();
    esp_task_wdt_reset();      // üîß FIX: Reset watchdog every loop
    vTaskDelay(pdMS_TO_TICKS(10));  // Yield CPU
  }
}
