// SPDX-FileCopyrightText: 2024 Cesanta Software Limited
// SPDX-License-Identifier: GPL-2.0-only or commercial
// Generated by Mongoose Wizard, https://mongoose.ws/wizard/

// Default mock implementation of the API callbacks

#include "mongoose_glue.h"
// Required only when MQTT messages are published from other tasks
void glue_lock_init(void) {
}
void glue_lock(void) {
}
void glue_unlock(void) {
}

// This implementation creates a very simple MQTT client that simply
// subscribes to the RX_TOPIC, waits for messages on that topic, and echoes
// the received message back to the TX_TOPIC.
//
// To override this implementation in your code, copy mqtt functions to your
// main.c, rename "glue_" to "my_", and add this before mongoose_init():
//
//  struct mongoose_mqtt_handlers mqtt_handlers = {
//      my_mqtt_connect,    my_mqtt_on_connect,
//      my_mqtt_on_message, my_mqtt_on_cmd,
//  };
//  mongoose_set_mqtt_handlers(&mqtt_handlers);
//
// If you want a more advanced example that implements device management with
// a device dashboard, remote firmware update and device control over MQTT, see
// https://mongoose.ws/mqtt-dashboard/ - device dashboard
// https://gist.github.com/cpq/ae11ec3073067325da31398fa7361d00 - device code

// Update this with the real CA certificate for the WIZARD_MQTT_URL
// Use https://mongoose.ws/tls/ to fetch CA certificate
#define TLS_CA ""
#define TX_TOPIC "device1/tx"
#define RX_TOPIC "device1/rx"

// Called when we connected to the MQTT server
void glue_mqtt_on_connect(struct mg_connection *c, int code) {
  struct mg_mqtt_opts opts;
  memset(&opts, 0, sizeof(opts));
  opts.qos = 1;
  opts.topic = mg_str(RX_TOPIC);  // Subscribe to the RX topic
  mg_mqtt_sub(c, &opts);
  MG_DEBUG(("%lu code %d. Subscribing to [%.*s]", c->id, code, opts.topic.len,
            opts.topic.buf));
}

// This function gets called for every received MQTT message
void glue_mqtt_on_message(struct mg_connection *c, struct mg_str topic,
                          struct mg_str data) {
  char tmp[100];
  mg_snprintf(tmp, sizeof(tmp), "Got [%.*s] -> [%.*s] !", topic.len, topic.buf,
              data.len, data.buf);
  MG_DEBUG(("%lu %s", c->id, tmp));

  if (g_mqtt_conn != NULL) {
    struct mg_mqtt_opts opts;        // Publish MQTT response
    memset(&opts, 0, sizeof(opts));  // to the TX topic
    opts.topic = mg_str(TX_TOPIC);
    opts.message = mg_str(tmp);
    mg_mqtt_pub(g_mqtt_conn, &opts);
  }
}

// This function is called on every control MQTT message
void glue_mqtt_on_cmd(struct mg_connection *c, struct mg_mqtt_message *mm) {
  MG_DEBUG(("%lu cmd %d qos %d", c->id, mm->cmd, mm->qos));
}

// This function creates MQTT server connection
struct mg_connection *glue_mqtt_connect(mg_event_handler_t fn) {
  const char *url = WIZARD_MQTT_URL;
  struct mg_connection *c;
  struct mg_mqtt_opts opts;
  memset(&opts, 0, sizeof(opts));
  opts.clean = true;
  // opts.keepalive = 5;
  if ((c = mg_mqtt_connect(&g_mgr, url, &opts, fn, NULL)) != NULL) {
    MG_DEBUG(("%lu TLS enabled: %s", c->id, c->is_tls ? "yes" : "no"));
    if (c->is_tls) {
      struct mg_tls_opts tls_opts;
      memset(&tls_opts, 0, sizeof(tls_opts));
      tls_opts.ca = mg_str(TLS_CA);
      tls_opts.name = mg_url_host(url);
      mg_tls_init(c, &tls_opts);
    }
  }
  return c;
}
